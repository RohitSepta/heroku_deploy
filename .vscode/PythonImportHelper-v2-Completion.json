[
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "dj_database_url",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dj_database_url",
        "description": "dj_database_url",
        "detail": "dj_database_url",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "popen",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "popen",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "popen",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "get_asgi_application",
        "importPath": "django.core.asgi",
        "description": "django.core.asgi",
        "isExtraImport": true,
        "detail": "django.core.asgi",
        "documentation": {}
    },
    {
        "label": "admin",
        "importPath": "django.contrib",
        "description": "django.contrib",
        "isExtraImport": true,
        "detail": "django.contrib",
        "documentation": {}
    },
    {
        "label": "admin",
        "importPath": "django.contrib",
        "description": "django.contrib",
        "isExtraImport": true,
        "detail": "django.contrib",
        "documentation": {}
    },
    {
        "label": "path",
        "importPath": "django.urls",
        "description": "django.urls",
        "isExtraImport": true,
        "detail": "django.urls",
        "documentation": {}
    },
    {
        "label": "get_wsgi_application",
        "importPath": "django.core.wsgi",
        "description": "django.core.wsgi",
        "isExtraImport": true,
        "detail": "django.core.wsgi",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argv",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "exit",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "hexversion",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stderr",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "mktime",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "ZipFile",
        "importPath": "zipfile",
        "description": "zipfile",
        "isExtraImport": true,
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "tempfile,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile.",
        "description": "tempfile.",
        "detail": "tempfile.",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "optparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "optparse",
        "description": "optparse",
        "detail": "optparse",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "marshal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "marshal",
        "description": "marshal",
        "detail": "marshal",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "stat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "stat",
        "description": "stat",
        "detail": "stat",
        "documentation": {}
    },
    {
        "label": "zlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zlib",
        "description": "zlib",
        "detail": "zlib",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "array",
        "description": "array",
        "detail": "array",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "Numeric",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "Numeric",
        "description": "Numeric",
        "detail": "Numeric",
        "documentation": {}
    },
    {
        "label": "types,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types.",
        "description": "types.",
        "detail": "types.",
        "documentation": {}
    },
    {
        "label": "sys,os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.os",
        "description": "sys.os",
        "detail": "sys.os",
        "documentation": {}
    },
    {
        "label": "dump",
        "importPath": "dump",
        "description": "dump",
        "isExtraImport": true,
        "detail": "dump",
        "documentation": {}
    },
    {
        "label": "dump",
        "importPath": "dump",
        "description": "dump",
        "isExtraImport": true,
        "detail": "dump",
        "documentation": {}
    },
    {
        "label": "dump",
        "importPath": "dump",
        "description": "dump",
        "isExtraImport": true,
        "detail": "dump",
        "documentation": {}
    },
    {
        "label": "dump",
        "importPath": "dump",
        "description": "dump",
        "isExtraImport": true,
        "detail": "dump",
        "documentation": {}
    },
    {
        "label": "cfg",
        "importPath": "cfg",
        "description": "cfg",
        "isExtraImport": true,
        "detail": "cfg",
        "documentation": {}
    },
    {
        "label": "pdbfile",
        "importPath": "pdbfile",
        "description": "pdbfile",
        "isExtraImport": true,
        "detail": "pdbfile",
        "documentation": {}
    },
    {
        "label": "xyz",
        "importPath": "xyz",
        "description": "xyz",
        "isExtraImport": true,
        "detail": "xyz",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "gnu",
        "importPath": "gnu",
        "description": "gnu",
        "isExtraImport": true,
        "detail": "gnu",
        "documentation": {}
    },
    {
        "label": "AppConfig",
        "importPath": "django.apps",
        "description": "django.apps",
        "isExtraImport": true,
        "detail": "django.apps",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "django.db",
        "description": "django.db",
        "isExtraImport": true,
        "detail": "django.db",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "django.test",
        "description": "django.test",
        "isExtraImport": true,
        "detail": "django.test",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "django.shortcuts",
        "description": "django.shortcuts",
        "isExtraImport": true,
        "detail": "django.shortcuts",
        "documentation": {}
    },
    {
        "label": "BASE_DIR",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "BASE_DIR = Path(__file__).resolve().parent.parent\n# Quick-start development settings - unsuitable for production\n# See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = 'django-insecure-fkbiqk3fleg%n)cv%9n)e$tkdrd_ywz9tlwf%8s6yro1!v8h84'\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\nALLOWED_HOSTS = []\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "SECRET_KEY = 'django-insecure-fkbiqk3fleg%n)cv%9n)e$tkdrd_ywz9tlwf%8s6yro1!v8h84'\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = True\nALLOWED_HOSTS = []\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'whitenoise.middleware.WhiteNoiseMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "DEBUG = True\nALLOWED_HOSTS = []\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'whitenoise.middleware.WhiteNoiseMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "ALLOWED_HOSTS",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "ALLOWED_HOSTS = []\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'whitenoise.middleware.WhiteNoiseMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "MIDDLEWARE",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "MIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'whitenoise.middleware.WhiteNoiseMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "ROOT_URLCONF",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "ROOT_URLCONF = 'deployment.urls'\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "TEMPLATES",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "TEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "WSGI_APPLICATION",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "WSGI_APPLICATION = 'deployment.wsgi.application'\n# Database\n# https://docs.djangoproject.com/en/3.2/ref/settings/#databases\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': BASE_DIR / 'db.sqlite3',\n    }\n}\nimport dj_database_url",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "DATABASES",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': BASE_DIR / 'db.sqlite3',\n    }\n}\nimport dj_database_url\ndb_from_env = dj_database_url.config(conn_max_age=500)\nDATABASES['default'].update(db_from_env)\n# Password validation",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "db_from_env",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "db_from_env = dj_database_url.config(conn_max_age=500)\nDATABASES['default'].update(db_from_env)\n# Password validation\n# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "AUTH_PASSWORD_VALIDATORS",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "AUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n    },",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "LANGUAGE_CODE",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "LANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'UTC'\nUSE_I18N = True\nUSE_L10N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/3.2/howto/static-files/\nSTATIC_URL = '/static/'\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static')\nSTATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "TIME_ZONE",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "TIME_ZONE = 'UTC'\nUSE_I18N = True\nUSE_L10N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/3.2/howto/static-files/\nSTATIC_URL = '/static/'\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static')\nSTATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'\n# Default primary key field type",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "USE_I18N",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "USE_I18N = True\nUSE_L10N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/3.2/howto/static-files/\nSTATIC_URL = '/static/'\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static')\nSTATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'\n# Default primary key field type\n# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "USE_L10N",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "USE_L10N = True\nUSE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/3.2/howto/static-files/\nSTATIC_URL = '/static/'\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static')\nSTATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'\n# Default primary key field type\n# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "USE_TZ",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "USE_TZ = True\n# Static files (CSS, JavaScript, Images)\n# https://docs.djangoproject.com/en/3.2/howto/static-files/\nSTATIC_URL = '/static/'\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static')\nSTATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'\n# Default primary key field type\n# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "STATIC_URL",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "STATIC_URL = '/static/'\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static')\nSTATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'\n# Default primary key field type\n# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "STATIC_ROOT",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "STATIC_ROOT = os.path.join(BASE_DIR, 'static')\nSTATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'\n# Default primary key field type\n# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "STATICFILES_STORAGE",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'\n# Default primary key field type\n# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "DEFAULT_AUTO_FIELD",
        "kind": 5,
        "importPath": "deployment.settings.base",
        "description": "deployment.settings.base",
        "peekOfCode": "DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'",
        "detail": "deployment.settings.base",
        "documentation": {}
    },
    {
        "label": "INSTALLED_APPS",
        "kind": 5,
        "importPath": "deployment.settings.local",
        "description": "deployment.settings.local",
        "peekOfCode": "INSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'myapp',\n    'whitenoise.runserver_nostatic',\n]",
        "detail": "deployment.settings.local",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "deployment.settings.production",
        "description": "deployment.settings.production",
        "peekOfCode": "SECRET_KEY = 'django-insecure-fkbiqk3fleg%n)cv%9n)e$tkdrd_ywz9tlwf%8s6yro1!v8h84'\nDEBUG = False\nALLOWED_HOSTS = ['127.0.0.1', '.herokuapp.com']",
        "detail": "deployment.settings.production",
        "documentation": {}
    },
    {
        "label": "DEBUG",
        "kind": 5,
        "importPath": "deployment.settings.production",
        "description": "deployment.settings.production",
        "peekOfCode": "DEBUG = False\nALLOWED_HOSTS = ['127.0.0.1', '.herokuapp.com']",
        "detail": "deployment.settings.production",
        "documentation": {}
    },
    {
        "label": "ALLOWED_HOSTS",
        "kind": 5,
        "importPath": "deployment.settings.production",
        "description": "deployment.settings.production",
        "peekOfCode": "ALLOWED_HOSTS = ['127.0.0.1', '.herokuapp.com']",
        "detail": "deployment.settings.production",
        "documentation": {}
    },
    {
        "label": "application",
        "kind": 5,
        "importPath": "deployment.asgi",
        "description": "deployment.asgi",
        "peekOfCode": "application = get_asgi_application()",
        "detail": "deployment.asgi",
        "documentation": {}
    },
    {
        "label": "urlpatterns",
        "kind": 5,
        "importPath": "deployment.urls",
        "description": "deployment.urls",
        "peekOfCode": "urlpatterns = [\n    path('admin/', admin.site.urls),\n]",
        "detail": "deployment.urls",
        "documentation": {}
    },
    {
        "label": "application",
        "kind": 5,
        "importPath": "deployment.wsgi",
        "description": "deployment.wsgi",
        "peekOfCode": "application = get_wsgi_application()",
        "detail": "deployment.wsgi",
        "documentation": {}
    },
    {
        "label": "printlines",
        "kind": 2,
        "importPath": "git.contrib.fast-import.import-zips",
        "description": "git.contrib.fast-import.import-zips",
        "peekOfCode": "def printlines(list):\n    for str in list:\n        fast_import.write(str + \"\\n\")\nfor zipfile in argv[1:]:\n    commit_time = 0\n    next_mark = 1\n    common_prefix = None\n    mark = dict()\n    zip = ZipFile(zipfile, 'r')\n    for name in zip.namelist():",
        "detail": "git.contrib.fast-import.import-zips",
        "documentation": {}
    },
    {
        "label": "branch_ref",
        "kind": 5,
        "importPath": "git.contrib.fast-import.import-zips",
        "description": "git.contrib.fast-import.import-zips",
        "peekOfCode": "branch_ref = 'refs/heads/import-zips'\ncommitter_name = 'Z Ip Creator'\ncommitter_email = 'zip@example.com'\nfast_import = popen('git fast-import --quiet', 'w')\ndef printlines(list):\n    for str in list:\n        fast_import.write(str + \"\\n\")\nfor zipfile in argv[1:]:\n    commit_time = 0\n    next_mark = 1",
        "detail": "git.contrib.fast-import.import-zips",
        "documentation": {}
    },
    {
        "label": "committer_name",
        "kind": 5,
        "importPath": "git.contrib.fast-import.import-zips",
        "description": "git.contrib.fast-import.import-zips",
        "peekOfCode": "committer_name = 'Z Ip Creator'\ncommitter_email = 'zip@example.com'\nfast_import = popen('git fast-import --quiet', 'w')\ndef printlines(list):\n    for str in list:\n        fast_import.write(str + \"\\n\")\nfor zipfile in argv[1:]:\n    commit_time = 0\n    next_mark = 1\n    common_prefix = None",
        "detail": "git.contrib.fast-import.import-zips",
        "documentation": {}
    },
    {
        "label": "committer_email",
        "kind": 5,
        "importPath": "git.contrib.fast-import.import-zips",
        "description": "git.contrib.fast-import.import-zips",
        "peekOfCode": "committer_email = 'zip@example.com'\nfast_import = popen('git fast-import --quiet', 'w')\ndef printlines(list):\n    for str in list:\n        fast_import.write(str + \"\\n\")\nfor zipfile in argv[1:]:\n    commit_time = 0\n    next_mark = 1\n    common_prefix = None\n    mark = dict()",
        "detail": "git.contrib.fast-import.import-zips",
        "documentation": {}
    },
    {
        "label": "fast_import",
        "kind": 5,
        "importPath": "git.contrib.fast-import.import-zips",
        "description": "git.contrib.fast-import.import-zips",
        "peekOfCode": "fast_import = popen('git fast-import --quiet', 'w')\ndef printlines(list):\n    for str in list:\n        fast_import.write(str + \"\\n\")\nfor zipfile in argv[1:]:\n    commit_time = 0\n    next_mark = 1\n    common_prefix = None\n    mark = dict()\n    zip = ZipFile(zipfile, 'r')",
        "detail": "git.contrib.fast-import.import-zips",
        "documentation": {}
    },
    {
        "label": "usage",
        "kind": 2,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "def usage():\n        print(\"\"\"\\\n%s: [OPTIONS] <hgprj>\noptions:\n    -s, --gitstate=FILE: name of the state to be saved/read\n                         for incrementals\n    -n, --nrepack=INT:   number of changesets that will trigger\n                         a repack (default=0, -1 to deactivate)\n    -v, --verbose:       be verbose\nrequired:",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "getgitenv",
        "kind": 2,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "def getgitenv(user, date):\n    env = ''\n    elems = re.compile('(.*?)\\s+<(.*)>').match(user)\n    if elems:\n        env += 'export GIT_AUTHOR_NAME=\"%s\" ;' % elems.group(1)\n        env += 'export GIT_COMMITTER_NAME=\"%s\" ;' % elems.group(1)\n        env += 'export GIT_AUTHOR_EMAIL=\"%s\" ;' % elems.group(2)\n        env += 'export GIT_COMMITTER_EMAIL=\"%s\" ;' % elems.group(2)\n    else:\n        env += 'export GIT_AUTHOR_NAME=\"%s\" ;' % user",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "hgvers",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "hgvers = {}\n# List of children for each hg revision\nhgchildren = {}\n# List of parents for each hg revision\nhgparents = {}\n# Current branch for each hg revision\nhgbranch = {}\n# Number of new changesets converted from hg\nhgnewcsets = 0\n#------------------------------------------------------------------------------",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "hgchildren",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "hgchildren = {}\n# List of parents for each hg revision\nhgparents = {}\n# Current branch for each hg revision\nhgbranch = {}\n# Number of new changesets converted from hg\nhgnewcsets = 0\n#------------------------------------------------------------------------------\ndef usage():\n        print(\"\"\"\\",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "hgparents",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "hgparents = {}\n# Current branch for each hg revision\nhgbranch = {}\n# Number of new changesets converted from hg\nhgnewcsets = 0\n#------------------------------------------------------------------------------\ndef usage():\n        print(\"\"\"\\\n%s: [OPTIONS] <hgprj>\noptions:",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "hgbranch",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "hgbranch = {}\n# Number of new changesets converted from hg\nhgnewcsets = 0\n#------------------------------------------------------------------------------\ndef usage():\n        print(\"\"\"\\\n%s: [OPTIONS] <hgprj>\noptions:\n    -s, --gitstate=FILE: name of the state to be saved/read\n                         for incrementals",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "hgnewcsets",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "hgnewcsets = 0\n#------------------------------------------------------------------------------\ndef usage():\n        print(\"\"\"\\\n%s: [OPTIONS] <hgprj>\noptions:\n    -s, --gitstate=FILE: name of the state to be saved/read\n                         for incrementals\n    -n, --nrepack=INT:   number of changesets that will trigger\n                         a repack (default=0, -1 to deactivate)",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "state",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "state = ''\nopt_nrepack = 0\nverbose = False\ntry:\n    opts, args = getopt.getopt(sys.argv[1:], 's:t:n:v', ['gitstate=', 'tempdir=', 'nrepack=', 'verbose'])\n    for o, a in opts:\n        if o in ('-s', '--gitstate'):\n            state = a\n            state = os.path.abspath(state)\n        if o in ('-n', '--nrepack'):",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "opt_nrepack",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "opt_nrepack = 0\nverbose = False\ntry:\n    opts, args = getopt.getopt(sys.argv[1:], 's:t:n:v', ['gitstate=', 'tempdir=', 'nrepack=', 'verbose'])\n    for o, a in opts:\n        if o in ('-s', '--gitstate'):\n            state = a\n            state = os.path.abspath(state)\n        if o in ('-n', '--nrepack'):\n            opt_nrepack = int(a)",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "verbose = False\ntry:\n    opts, args = getopt.getopt(sys.argv[1:], 's:t:n:v', ['gitstate=', 'tempdir=', 'nrepack=', 'verbose'])\n    for o, a in opts:\n        if o in ('-s', '--gitstate'):\n            state = a\n            state = os.path.abspath(state)\n        if o in ('-n', '--nrepack'):\n            opt_nrepack = int(a)\n        if o in ('-v', '--verbose'):",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "hgprj",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "hgprj = args[0]\nos.chdir(hgprj)\nif state:\n    if os.path.exists(state):\n        if verbose:\n            print('State does exist, reading')\n        f = open(state, 'r')\n        hgvers = pickle.load(f)\n    else:\n        print('State does not exist, first run')",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "sock",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "sock = os.popen('hg tip --template \"{rev}\"')\ntip = sock.read()\nif sock.close():\n    sys.exit(1)\nif verbose:\n    print('tip is', tip)\n# Calculate the branches\nif verbose:\n    print('analysing the branches...')\nhgchildren[\"0\"] = ()",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "tip",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "tip = sock.read()\nif sock.close():\n    sys.exit(1)\nif verbose:\n    print('tip is', tip)\n# Calculate the branches\nif verbose:\n    print('analysing the branches...')\nhgchildren[\"0\"] = ()\nhgparents[\"0\"] = (None, None)",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "hgchildren[\"0\"]",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "hgchildren[\"0\"] = ()\nhgparents[\"0\"] = (None, None)\nhgbranch[\"0\"] = \"master\"\nfor cset in range(1, int(tip) + 1):\n    hgchildren[str(cset)] = ()\n    prnts = os.popen('hg log -r %d --template \"{parents}\"' % cset).read().strip().split(' ')\n    prnts = map(lambda x: x[:x.find(':')], prnts)\n    if prnts[0] != '':\n        parent = prnts[0].strip()\n    else:",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "hgparents[\"0\"]",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "hgparents[\"0\"] = (None, None)\nhgbranch[\"0\"] = \"master\"\nfor cset in range(1, int(tip) + 1):\n    hgchildren[str(cset)] = ()\n    prnts = os.popen('hg log -r %d --template \"{parents}\"' % cset).read().strip().split(' ')\n    prnts = map(lambda x: x[:x.find(':')], prnts)\n    if prnts[0] != '':\n        parent = prnts[0].strip()\n    else:\n        parent = str(cset - 1)",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "hgbranch[\"0\"]",
        "kind": 5,
        "importPath": "git.contrib.hg-to-git.hg-to-git",
        "description": "git.contrib.hg-to-git.hg-to-git",
        "peekOfCode": "hgbranch[\"0\"] = \"master\"\nfor cset in range(1, int(tip) + 1):\n    hgchildren[str(cset)] = ()\n    prnts = os.popen('hg log -r %d --template \"{parents}\"' % cset).read().strip().split(' ')\n    prnts = map(lambda x: x[:x.find(':')], prnts)\n    if prnts[0] != '':\n        parent = prnts[0].strip()\n    else:\n        parent = str(cset - 1)\n    hgchildren[parent] += ( str(cset), )",
        "detail": "git.contrib.hg-to-git.hg-to-git",
        "documentation": {}
    },
    {
        "label": "P4Exception",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4Exception(Exception):\n    \"\"\" Base class for exceptions from the p4 client \"\"\"\n    def __init__(self, exit_code):\n        self.p4ExitCode = exit_code\nclass P4ServerException(P4Exception):\n    \"\"\" Base class for exceptions where we get some kind of marshalled up result from the server \"\"\"\n    def __init__(self, exit_code, p4_result):\n        super(P4ServerException, self).__init__(exit_code)\n        self.p4_result = p4_result\n        self.code = p4_result[0]['code']",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "P4ServerException",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4ServerException(P4Exception):\n    \"\"\" Base class for exceptions where we get some kind of marshalled up result from the server \"\"\"\n    def __init__(self, exit_code, p4_result):\n        super(P4ServerException, self).__init__(exit_code)\n        self.p4_result = p4_result\n        self.code = p4_result[0]['code']\n        self.data = p4_result[0]['data']\nclass P4RequestSizeException(P4ServerException):\n    \"\"\" One of the maxresults or maxscanrows errors \"\"\"\n    def __init__(self, exit_code, p4_result, limit):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "P4RequestSizeException",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4RequestSizeException(P4ServerException):\n    \"\"\" One of the maxresults or maxscanrows errors \"\"\"\n    def __init__(self, exit_code, p4_result, limit):\n        super(P4RequestSizeException, self).__init__(exit_code, p4_result)\n        self.limit = limit\nclass P4CommandException(P4Exception):\n    \"\"\" Something went wrong calling p4 which means we have to give up \"\"\"\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "P4CommandException",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4CommandException(P4Exception):\n    \"\"\" Something went wrong calling p4 which means we have to give up \"\"\"\n    def __init__(self, msg):\n        self.msg = msg\n    def __str__(self):\n        return self.msg\ndef isModeExecChanged(src_mode, dst_mode):\n    return isModeExec(src_mode) != isModeExec(dst_mode)\ndef p4CmdList(cmd, stdin=None, stdin_mode='w+b', cb=None, skip_info=False,\n        errors_as_exceptions=False, *k, **kw):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "LargeFileSystem",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class LargeFileSystem(object):\n    \"\"\"Base class for large file system support.\"\"\"\n    def __init__(self, writeToGitStream):\n        self.largeFiles = set()\n        self.writeToGitStream = writeToGitStream\n    def generatePointer(self, cloneDestination, contentFile):\n        \"\"\"Return the content of a pointer file that is stored in Git instead of\n           the actual content.\"\"\"\n        assert False, \"Method 'generatePointer' required in \" + self.__class__.__name__\n    def pushFile(self, localLargeFile):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "MockLFS",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class MockLFS(LargeFileSystem):\n    \"\"\"Mock large file system for testing.\"\"\"\n    def generatePointer(self, contentFile):\n        \"\"\"The pointer content is the original content prefixed with \"pointer-\".\n           The local filename of the large file storage is derived from the file content.\n           \"\"\"\n        with open(contentFile, 'r') as f:\n            content = next(f)\n            gitMode = '100644'\n            pointerContents = 'pointer-' + content",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "GitLFS",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class GitLFS(LargeFileSystem):\n    \"\"\"Git LFS as backend for the git-p4 large file system.\n       See https://git-lfs.github.com/ for details.\"\"\"\n    def __init__(self, *args):\n        LargeFileSystem.__init__(self, *args)\n        self.baseGitAttributes = []\n    def generatePointer(self, contentFile):\n        \"\"\"Generate a Git LFS pointer for the content. Return LFS Pointer file\n           mode and content which is stored in the Git repository instead of\n           the actual content. Return also the new location of the actual",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "Command",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class Command:\n    delete_actions = ( \"delete\", \"move/delete\", \"purge\" )\n    add_actions = ( \"add\", \"branch\", \"move/add\" )\n    def __init__(self):\n        self.usage = \"usage: %prog [options]\"\n        self.needsGit = True\n        self.verbose = False\n    # This is required for the \"append\" update_shelve action\n    def ensure_value(self, attr, value):\n        if not hasattr(self, attr) or getattr(self, attr) is None:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "P4UserMap",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4UserMap:\n    def __init__(self):\n        self.userMapFromPerforceServer = False\n        self.myP4UserId = None\n    def p4UserId(self):\n        if self.myP4UserId:\n            return self.myP4UserId\n        results = p4CmdList([\"user\", \"-o\"])\n        for r in results:\n            if 'User' in r:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "P4Submit",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4Submit(Command, P4UserMap):\n    conflict_behavior_choices = (\"ask\", \"skip\", \"quit\")\n    def __init__(self):\n        Command.__init__(self)\n        P4UserMap.__init__(self)\n        self.options = [\n                optparse.make_option(\"--origin\", dest=\"origin\"),\n                optparse.make_option(\"-M\", dest=\"detectRenames\", action=\"store_true\"),\n                # preserve the user, requires relevant p4 permissions\n                optparse.make_option(\"--preserve-user\", dest=\"preserveUser\", action=\"store_true\"),",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "View",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class View(object):\n    \"\"\"Represent a p4 view (\"p4 help views\"), and map files in a\n       repo according to the view.\"\"\"\n    def __init__(self, client_name):\n        self.mappings = []\n        self.client_prefix = \"//%s/\" % client_name\n        # cache results of \"p4 where\" to lookup client file locations\n        self.client_spec_path_cache = {}\n    def append(self, view_line):\n        \"\"\"Parse a view line, splitting it into depot and client",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "P4Sync",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4Sync(Command, P4UserMap):\n    def __init__(self):\n        Command.__init__(self)\n        P4UserMap.__init__(self)\n        self.options = [\n                optparse.make_option(\"--branch\", dest=\"branch\"),\n                optparse.make_option(\"--detect-branches\", dest=\"detectBranches\", action=\"store_true\"),\n                optparse.make_option(\"--changesfile\", dest=\"changesFile\"),\n                optparse.make_option(\"--silent\", dest=\"silent\", action=\"store_true\"),\n                optparse.make_option(\"--detect-labels\", dest=\"detectLabels\", action=\"store_true\"),",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "P4Rebase",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4Rebase(Command):\n    def __init__(self):\n        Command.__init__(self)\n        self.options = [\n                optparse.make_option(\"--import-labels\", dest=\"importLabels\", action=\"store_true\"),\n        ]\n        self.importLabels = False\n        self.description = (\"Fetches the latest revision from perforce and \"\n                            + \"rebases the current work (branch) against it\")\n    def run(self, args):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "P4Clone",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4Clone(P4Sync):\n    def __init__(self):\n        P4Sync.__init__(self)\n        self.description = \"Creates a new git repository and imports from Perforce into it\"\n        self.usage = \"usage: %prog [options] //depot/path[@revRange]\"\n        self.options += [\n            optparse.make_option(\"--destination\", dest=\"cloneDestination\",\n                                 action='store', default=None,\n                                 help=\"where to leave result of the clone\"),\n            optparse.make_option(\"--bare\", dest=\"cloneBare\",",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "P4Unshelve",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4Unshelve(Command):\n    def __init__(self):\n        Command.__init__(self)\n        self.options = []\n        self.origin = \"HEAD\"\n        self.description = \"Unshelve a P4 changelist into a git commit\"\n        self.usage = \"usage: %prog [options] changelist\"\n        self.options += [\n                optparse.make_option(\"--origin\", dest=\"origin\",\n                    help=\"Use this base revision instead of the default (%s)\" % self.origin),",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "P4Branches",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class P4Branches(Command):\n    def __init__(self):\n        Command.__init__(self)\n        self.options = [ ]\n        self.description = (\"Shows the git branches that hold imports and their \"\n                            + \"corresponding perforce depot paths\")\n        self.verbose = False\n    def run(self, args):\n        if originP4BranchesExist():\n            createOrUpdateBranchesFromOrigin()",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "HelpFormatter",
        "kind": 6,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "class HelpFormatter(optparse.IndentedHelpFormatter):\n    def __init__(self):\n        optparse.IndentedHelpFormatter.__init__(self)\n    def format_description(self, description):\n        if description:\n            return description + \"\\n\"\n        else:\n            return \"\"\ndef printUsage(commands):\n    print(\"usage: %s <command> [options]\" % sys.argv[0])",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "format_size_human_readable",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def format_size_human_readable(num):\n    \"\"\" Returns a number of units (typically bytes) formatted as a human-readable\n        string.\n    \"\"\"\n    if num < 1024:\n        return '{:d} B'.format(num)\n    for unit in [\"Ki\", \"Mi\", \"Gi\", \"Ti\", \"Pi\", \"Ei\", \"Zi\"]:\n        num /= 1024.0\n        if num < 1024.0:\n            return \"{:3.1f} {}B\".format(num, unit)",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_build_cmd",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_build_cmd(cmd):\n    \"\"\"Build a suitable p4 command line.\n    This consolidates building and returning a p4 command line into one\n    location. It means that hooking into the environment, or other configuration\n    can be done more easily.\n    \"\"\"\n    real_cmd = [\"p4\"]\n    user = gitConfig(\"git-p4.user\")\n    if len(user) > 0:\n        real_cmd += [\"-u\",user]",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "git_dir",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def git_dir(path):\n    \"\"\" Return TRUE if the given path is a git directory (/path/to/dir/.git).\n        This won't automatically add \".git\" to a directory.\n    \"\"\"\n    d = read_pipe([\"git\", \"--git-dir\", path, \"rev-parse\", \"--git-dir\"], True).strip()\n    if not d or len(d) == 0:\n        return None\n    else:\n        return d\ndef chdir(path, is_client_path=False):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "chdir",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def chdir(path, is_client_path=False):\n    \"\"\"Do chdir to the given path, and set the PWD environment\n       variable for use by P4.  It does not look at getcwd() output.\n       Since we're not using the shell, it is necessary to set the\n       PWD environment variable explicitly.\n       Normally, expand the path to force it to be absolute.  This\n       addresses the use of relative path names inside P4 settings,\n       e.g. P4CONFIG=.p4config.  P4 does not simply open the filename\n       as given; it looks for .p4config using PWD.\n       If is_client_path, the path was handed to us directly by p4,",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "calcDiskFree",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def calcDiskFree():\n    \"\"\"Return free space in bytes on the disk of the given dirname.\"\"\"\n    if platform.system() == 'Windows':\n        free_bytes = ctypes.c_ulonglong(0)\n        ctypes.windll.kernel32.GetDiskFreeSpaceExW(ctypes.c_wchar_p(os.getcwd()), None, None, ctypes.pointer(free_bytes))\n        return free_bytes.value\n    else:\n        st = os.statvfs(os.getcwd())\n        return st.f_bavail * st.f_frsize\ndef die(msg):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "die",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def die(msg):\n    \"\"\" Terminate execution. Make sure that any running child processes have been wait()ed for before\n        calling this.\n    \"\"\"\n    if verbose:\n        raise Exception(msg)\n    else:\n        sys.stderr.write(msg + \"\\n\")\n        sys.exit(1)\ndef prompt(prompt_text):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "prompt",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def prompt(prompt_text):\n    \"\"\" Prompt the user to choose one of the choices\n    Choices are identified in the prompt_text by square brackets around\n    a single letter option.\n    \"\"\"\n    choices = set(m.group(1) for m in re.finditer(r\"\\[(.)\\]\", prompt_text))\n    while True:\n        sys.stderr.flush()\n        sys.stdout.write(prompt_text)\n        sys.stdout.flush()",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "decode_path",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def decode_path(path):\n    \"\"\"Decode a given string (bytes or otherwise) using configured path encoding options\n    \"\"\"\n    encoding = gitConfig('git-p4.pathEncoding') or 'utf_8'\n    if bytes is not str:\n        return path.decode(encoding, errors='replace') if isinstance(path, bytes) else path\n    else:\n        try:\n            path.decode('ascii')\n        except:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "run_git_hook",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def run_git_hook(cmd, param=[]):\n    \"\"\"Execute a hook if the hook exists.\"\"\"\n    args = ['git', 'hook', 'run', '--ignore-missing', cmd]\n    if param:\n        args.append(\"--\")\n        for p in param:\n            args.append(p)\n    return subprocess.call(args) == 0\ndef write_pipe(c, stdin, *k, **kw):\n    if verbose:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "write_pipe",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def write_pipe(c, stdin, *k, **kw):\n    if verbose:\n        sys.stderr.write('Writing pipe: {}\\n'.format(' '.join(c)))\n    p = subprocess.Popen(c, stdin=subprocess.PIPE, *k, **kw)\n    pipe = p.stdin\n    val = pipe.write(stdin)\n    pipe.close()\n    if p.wait():\n        die('Command failed: {}'.format(' '.join(c)))\n    return val",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_write_pipe",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_write_pipe(c, stdin, *k, **kw):\n    real_cmd = p4_build_cmd(c)\n    if bytes is not str and isinstance(stdin, str):\n        stdin = encode_text_stream(stdin)\n    return write_pipe(real_cmd, stdin, *k, **kw)\ndef read_pipe_full(c, *k, **kw):\n    \"\"\" Read output from  command. Returns a tuple\n        of the return status, stdout text and stderr\n        text.\n    \"\"\"",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "read_pipe_full",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def read_pipe_full(c, *k, **kw):\n    \"\"\" Read output from  command. Returns a tuple\n        of the return status, stdout text and stderr\n        text.\n    \"\"\"\n    if verbose:\n        sys.stderr.write('Reading pipe: {}\\n'.format(' '.join(c)))\n    p = subprocess.Popen(\n        c, stdout=subprocess.PIPE, stderr=subprocess.PIPE, *k, **kw)\n    (out, err) = p.communicate()",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "read_pipe",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def read_pipe(c, ignore_error=False, raw=False, *k, **kw):\n    \"\"\" Read output from  command. Returns the output text on\n        success. On failure, terminates execution, unless\n        ignore_error is True, when it returns an empty string.\n        If raw is True, do not attempt to decode output text.\n    \"\"\"\n    (retcode, out, err) = read_pipe_full(c, *k, **kw)\n    if retcode != 0:\n        if ignore_error:\n            out = \"\"",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "read_pipe_text",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def read_pipe_text(c, *k, **kw):\n    \"\"\" Read output from a command with trailing whitespace stripped.\n        On error, returns None.\n    \"\"\"\n    (retcode, out, err) = read_pipe_full(c, *k, **kw)\n    if retcode != 0:\n        return None\n    else:\n        return decode_text_stream(out).rstrip()\ndef p4_read_pipe(c, ignore_error=False, raw=False, *k, **kw):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_read_pipe",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_read_pipe(c, ignore_error=False, raw=False, *k, **kw):\n    real_cmd = p4_build_cmd(c)\n    return read_pipe(real_cmd, ignore_error, raw=raw, *k, **kw)\ndef read_pipe_lines(c, raw=False, *k, **kw):\n    if verbose:\n        sys.stderr.write('Reading pipe: {}\\n'.format(' '.join(c)))\n    p = subprocess.Popen(c, stdout=subprocess.PIPE, *k, **kw)\n    pipe = p.stdout\n    lines = pipe.readlines()\n    if not raw:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "read_pipe_lines",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def read_pipe_lines(c, raw=False, *k, **kw):\n    if verbose:\n        sys.stderr.write('Reading pipe: {}\\n'.format(' '.join(c)))\n    p = subprocess.Popen(c, stdout=subprocess.PIPE, *k, **kw)\n    pipe = p.stdout\n    lines = pipe.readlines()\n    if not raw:\n        lines = [decode_text_stream(line) for line in lines]\n    if pipe.close() or p.wait():\n        die('Command failed: {}'.format(' '.join(c)))",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_read_pipe_lines",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_read_pipe_lines(c, *k, **kw):\n    \"\"\"Specifically invoke p4 on the command supplied. \"\"\"\n    real_cmd = p4_build_cmd(c)\n    return read_pipe_lines(real_cmd, *k, **kw)\ndef p4_has_command(cmd):\n    \"\"\"Ask p4 for help on this command.  If it returns an error, the\n       command does not exist in this version of p4.\"\"\"\n    real_cmd = p4_build_cmd([\"help\", cmd])\n    p = subprocess.Popen(real_cmd, stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_has_command",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_has_command(cmd):\n    \"\"\"Ask p4 for help on this command.  If it returns an error, the\n       command does not exist in this version of p4.\"\"\"\n    real_cmd = p4_build_cmd([\"help\", cmd])\n    p = subprocess.Popen(real_cmd, stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)\n    p.communicate()\n    return p.returncode == 0\ndef p4_has_move_command():\n    \"\"\"See if the move command exists, that it supports -k, and that",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_has_move_command",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_has_move_command():\n    \"\"\"See if the move command exists, that it supports -k, and that\n       it has not been administratively disabled.  The arguments\n       must be correct, but the filenames do not have to exist.  Use\n       ones with wildcards so even if they exist, it will fail.\"\"\"\n    if not p4_has_command(\"move\"):\n        return False\n    cmd = p4_build_cmd([\"move\", \"-k\", \"@from\", \"@to\"])\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    (out, err) = p.communicate()",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "system",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def system(cmd, ignore_error=False, *k, **kw):\n    if verbose:\n        sys.stderr.write(\"executing {}\\n\".format(\n            ' '.join(cmd) if isinstance(cmd, list) else cmd))\n    retcode = subprocess.call(cmd, *k, **kw)\n    if retcode and not ignore_error:\n        raise subprocess.CalledProcessError(retcode, cmd)\n    return retcode\ndef p4_system(cmd, *k, **kw):\n    \"\"\"Specifically invoke p4 as the system command. \"\"\"",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_system",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_system(cmd, *k, **kw):\n    \"\"\"Specifically invoke p4 as the system command. \"\"\"\n    real_cmd = p4_build_cmd(cmd)\n    retcode = subprocess.call(real_cmd, *k, **kw)\n    if retcode:\n        raise subprocess.CalledProcessError(retcode, real_cmd)\ndef die_bad_access(s):\n    die(\"failure accessing depot: {0}\".format(s.rstrip()))\ndef p4_check_access(min_expiration=1):\n    \"\"\" Check if we can access Perforce - account still logged in",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "die_bad_access",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def die_bad_access(s):\n    die(\"failure accessing depot: {0}\".format(s.rstrip()))\ndef p4_check_access(min_expiration=1):\n    \"\"\" Check if we can access Perforce - account still logged in\n    \"\"\"\n    results = p4CmdList([\"login\", \"-s\"])\n    if len(results) == 0:\n        # should never get here: always get either some results, or a p4ExitCode\n        assert(\"could not parse response from perforce\")\n    result = results[0]",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_check_access",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_check_access(min_expiration=1):\n    \"\"\" Check if we can access Perforce - account still logged in\n    \"\"\"\n    results = p4CmdList([\"login\", \"-s\"])\n    if len(results) == 0:\n        # should never get here: always get either some results, or a p4ExitCode\n        assert(\"could not parse response from perforce\")\n    result = results[0]\n    if 'p4ExitCode' in result:\n        # p4 returned non-zero status, e.g. P4PORT invalid, or p4 not in path",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_version_string",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_version_string():\n    \"\"\"Read the version string, showing just the last line, which\n       hopefully is the interesting version bit.\n       $ p4 -V\n       Perforce - The Fast Software Configuration Management System.\n       Copyright 1995-2011 Perforce Software.  All rights reserved.\n       Rev. P4/NTX86/2011.1/393975 (2011/12/16).\n    \"\"\"\n    global _p4_version_string\n    if not _p4_version_string:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_integrate",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_integrate(src, dest):\n    p4_system([\"integrate\", \"-Dt\", wildcard_encode(src), wildcard_encode(dest)])\ndef p4_sync(f, *options):\n    p4_system([\"sync\"] + list(options) + [wildcard_encode(f)])\ndef p4_add(f):\n    # forcibly add file names with wildcards\n    if wildcard_present(f):\n        p4_system([\"add\", \"-f\", f])\n    else:\n        p4_system([\"add\", f])",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_sync",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_sync(f, *options):\n    p4_system([\"sync\"] + list(options) + [wildcard_encode(f)])\ndef p4_add(f):\n    # forcibly add file names with wildcards\n    if wildcard_present(f):\n        p4_system([\"add\", \"-f\", f])\n    else:\n        p4_system([\"add\", f])\ndef p4_delete(f):\n    p4_system([\"delete\", wildcard_encode(f)])",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_add",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_add(f):\n    # forcibly add file names with wildcards\n    if wildcard_present(f):\n        p4_system([\"add\", \"-f\", f])\n    else:\n        p4_system([\"add\", f])\ndef p4_delete(f):\n    p4_system([\"delete\", wildcard_encode(f)])\ndef p4_edit(f, *options):\n    p4_system([\"edit\"] + list(options) + [wildcard_encode(f)])",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_delete",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_delete(f):\n    p4_system([\"delete\", wildcard_encode(f)])\ndef p4_edit(f, *options):\n    p4_system([\"edit\"] + list(options) + [wildcard_encode(f)])\ndef p4_revert(f):\n    p4_system([\"revert\", wildcard_encode(f)])\ndef p4_reopen(type, f):\n    p4_system([\"reopen\", \"-t\", type, wildcard_encode(f)])\ndef p4_reopen_in_change(changelist, files):\n    cmd = [\"reopen\", \"-c\", str(changelist)] + files",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_edit",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_edit(f, *options):\n    p4_system([\"edit\"] + list(options) + [wildcard_encode(f)])\ndef p4_revert(f):\n    p4_system([\"revert\", wildcard_encode(f)])\ndef p4_reopen(type, f):\n    p4_system([\"reopen\", \"-t\", type, wildcard_encode(f)])\ndef p4_reopen_in_change(changelist, files):\n    cmd = [\"reopen\", \"-c\", str(changelist)] + files\n    p4_system(cmd)\ndef p4_move(src, dest):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_revert",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_revert(f):\n    p4_system([\"revert\", wildcard_encode(f)])\ndef p4_reopen(type, f):\n    p4_system([\"reopen\", \"-t\", type, wildcard_encode(f)])\ndef p4_reopen_in_change(changelist, files):\n    cmd = [\"reopen\", \"-c\", str(changelist)] + files\n    p4_system(cmd)\ndef p4_move(src, dest):\n    p4_system([\"move\", \"-k\", wildcard_encode(src), wildcard_encode(dest)])\ndef p4_last_change():",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_reopen",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_reopen(type, f):\n    p4_system([\"reopen\", \"-t\", type, wildcard_encode(f)])\ndef p4_reopen_in_change(changelist, files):\n    cmd = [\"reopen\", \"-c\", str(changelist)] + files\n    p4_system(cmd)\ndef p4_move(src, dest):\n    p4_system([\"move\", \"-k\", wildcard_encode(src), wildcard_encode(dest)])\ndef p4_last_change():\n    results = p4CmdList([\"changes\", \"-m\", \"1\"], skip_info=True)\n    return int(results[0]['change'])",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_reopen_in_change",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_reopen_in_change(changelist, files):\n    cmd = [\"reopen\", \"-c\", str(changelist)] + files\n    p4_system(cmd)\ndef p4_move(src, dest):\n    p4_system([\"move\", \"-k\", wildcard_encode(src), wildcard_encode(dest)])\ndef p4_last_change():\n    results = p4CmdList([\"changes\", \"-m\", \"1\"], skip_info=True)\n    return int(results[0]['change'])\ndef p4_describe(change, shelved=False):\n    \"\"\"Make sure it returns a valid result by checking for",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_move",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_move(src, dest):\n    p4_system([\"move\", \"-k\", wildcard_encode(src), wildcard_encode(dest)])\ndef p4_last_change():\n    results = p4CmdList([\"changes\", \"-m\", \"1\"], skip_info=True)\n    return int(results[0]['change'])\ndef p4_describe(change, shelved=False):\n    \"\"\"Make sure it returns a valid result by checking for\n       the presence of field \"time\".  Return a dict of the\n       results.\"\"\"\n    cmd = [\"describe\", \"-s\"]",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_last_change",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_last_change():\n    results = p4CmdList([\"changes\", \"-m\", \"1\"], skip_info=True)\n    return int(results[0]['change'])\ndef p4_describe(change, shelved=False):\n    \"\"\"Make sure it returns a valid result by checking for\n       the presence of field \"time\".  Return a dict of the\n       results.\"\"\"\n    cmd = [\"describe\", \"-s\"]\n    if shelved:\n        cmd += [\"-S\"]",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_describe",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_describe(change, shelved=False):\n    \"\"\"Make sure it returns a valid result by checking for\n       the presence of field \"time\".  Return a dict of the\n       results.\"\"\"\n    cmd = [\"describe\", \"-s\"]\n    if shelved:\n        cmd += [\"-S\"]\n    cmd += [str(change)]\n    ds = p4CmdList(cmd, skip_info=True)\n    if len(ds) != 1:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "split_p4_type",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def split_p4_type(p4type):\n    p4_filetypes_historical = {\n        \"ctempobj\": \"binary+Sw\",\n        \"ctext\": \"text+C\",\n        \"cxtext\": \"text+Cx\",\n        \"ktext\": \"text+k\",\n        \"kxtext\": \"text+kx\",\n        \"ltext\": \"text+F\",\n        \"tempobj\": \"binary+FSw\",\n        \"ubinary\": \"binary+F\",",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_type",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_type(f):\n    results = p4CmdList([\"fstat\", \"-T\", \"headType\", wildcard_encode(f)])\n    return results[0]['headType']\n#\n# Given a type base and modifier, return a regexp matching\n# the keywords that can be expanded in the file\n#\ndef p4_keywords_regexp_for_type(base, type_mods):\n    if base in (\"text\", \"unicode\", \"binary\"):\n        if \"ko\" in type_mods:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_keywords_regexp_for_type",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_keywords_regexp_for_type(base, type_mods):\n    if base in (\"text\", \"unicode\", \"binary\"):\n        if \"ko\" in type_mods:\n            return re_ko_keywords\n        elif \"k\" in type_mods:\n            return re_k_keywords\n        else:\n            return None\n    else:\n        return None",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_keywords_regexp_for_file",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4_keywords_regexp_for_file(file):\n    if not os.path.exists(file):\n        return None\n    else:\n        (type_base, type_mods) = split_p4_type(p4_type(file))\n        return p4_keywords_regexp_for_type(type_base, type_mods)\ndef setP4ExecBit(file, mode):\n    # Reopens an already open file and changes the execute bit to match\n    # the execute bit setting in the passed in mode.\n    p4Type = \"+x\"",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "setP4ExecBit",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def setP4ExecBit(file, mode):\n    # Reopens an already open file and changes the execute bit to match\n    # the execute bit setting in the passed in mode.\n    p4Type = \"+x\"\n    if not isModeExec(mode):\n        p4Type = getP4OpenedType(file)\n        p4Type = re.sub('^([cku]?)x(.*)', '\\\\1\\\\2', p4Type)\n        p4Type = re.sub('(.*?\\+.*?)x(.*?)', '\\\\1\\\\2', p4Type)\n        if p4Type[-1] == \"+\":\n            p4Type = p4Type[0:-1]",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "getP4OpenedType",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def getP4OpenedType(file):\n    # Returns the perforce file type for the given file.\n    result = p4_read_pipe([\"opened\", wildcard_encode(file)])\n    match = re.match(\".*\\((.+)\\)( \\*exclusive\\*)?\\r?$\", result)\n    if match:\n        return match.group(1)\n    else:\n        die(\"Could not determine file type for %s (result: '%s')\" % (file, result))\n# Return the set of all p4 labels\ndef getP4Labels(depotPaths):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "getP4Labels",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def getP4Labels(depotPaths):\n    labels = set()\n    if not isinstance(depotPaths, list):\n        depotPaths = [depotPaths]\n    for l in p4CmdList([\"labels\"] + [\"%s...\" % p for p in depotPaths]):\n        label = l['label']\n        labels.add(label)\n    return labels\n# Return the set of all git tags\ndef getGitTags():",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "getGitTags",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def getGitTags():\n    gitTags = set()\n    for line in read_pipe_lines([\"git\", \"tag\"]):\n        tag = line.strip()\n        gitTags.add(tag)\n    return gitTags\n_diff_tree_pattern = None\ndef parseDiffTreeEntry(entry):\n    \"\"\"Parses a single diff tree entry into its component elements.\n    See git-diff-tree(1) manpage for details about the format of the diff",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "parseDiffTreeEntry",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def parseDiffTreeEntry(entry):\n    \"\"\"Parses a single diff tree entry into its component elements.\n    See git-diff-tree(1) manpage for details about the format of the diff\n    output. This method returns a dictionary with the following elements:\n    src_mode - The mode of the source file\n    dst_mode - The mode of the destination file\n    src_sha1 - The sha1 for the source file\n    dst_sha1 - The sha1 fr the destination file\n    status - The one letter status of the diff (i.e. 'A', 'M', 'D', etc)\n    status_score - The score for the status (applicable for 'C' and 'R'",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "isModeExec",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def isModeExec(mode):\n    # Returns True if the given git mode represents an executable file,\n    # otherwise False.\n    return mode[-3:] == \"755\"\nclass P4Exception(Exception):\n    \"\"\" Base class for exceptions from the p4 client \"\"\"\n    def __init__(self, exit_code):\n        self.p4ExitCode = exit_code\nclass P4ServerException(P4Exception):\n    \"\"\" Base class for exceptions where we get some kind of marshalled up result from the server \"\"\"",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "isModeExecChanged",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def isModeExecChanged(src_mode, dst_mode):\n    return isModeExec(src_mode) != isModeExec(dst_mode)\ndef p4CmdList(cmd, stdin=None, stdin_mode='w+b', cb=None, skip_info=False,\n        errors_as_exceptions=False, *k, **kw):\n    cmd = p4_build_cmd([\"-G\"] + cmd)\n    if verbose:\n        sys.stderr.write(\"Opening pipe: {}\\n\".format(' '.join(cmd)))\n    # Use a temporary file to avoid deadlocks without\n    # subprocess.communicate(), which would put another copy\n    # of stdout into memory.",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4CmdList",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4CmdList(cmd, stdin=None, stdin_mode='w+b', cb=None, skip_info=False,\n        errors_as_exceptions=False, *k, **kw):\n    cmd = p4_build_cmd([\"-G\"] + cmd)\n    if verbose:\n        sys.stderr.write(\"Opening pipe: {}\\n\".format(' '.join(cmd)))\n    # Use a temporary file to avoid deadlocks without\n    # subprocess.communicate(), which would put another copy\n    # of stdout into memory.\n    stdin_file = None\n    if stdin is not None:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4Cmd",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4Cmd(cmd, *k, **kw):\n    list = p4CmdList(cmd, *k, **kw)\n    result = {}\n    for entry in list:\n        result.update(entry)\n    return result;\ndef p4Where(depotPath):\n    if not depotPath.endswith(\"/\"):\n        depotPath += \"/\"\n    depotPathLong = depotPath + \"...\"",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4Where",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4Where(depotPath):\n    if not depotPath.endswith(\"/\"):\n        depotPath += \"/\"\n    depotPathLong = depotPath + \"...\"\n    outputList = p4CmdList([\"where\", depotPathLong])\n    output = None\n    for entry in outputList:\n        if \"depotFile\" in entry:\n            # Search for the base client side depot path, as long as it starts with the branch's P4 path.\n            # The base path always ends with \"/...\".",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "currentGitBranch",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def currentGitBranch():\n    return read_pipe_text([\"git\", \"symbolic-ref\", \"--short\", \"-q\", \"HEAD\"])\ndef isValidGitDir(path):\n    return git_dir(path) != None\ndef parseRevision(ref):\n    return read_pipe([\"git\", \"rev-parse\", ref]).strip()\ndef branchExists(ref):\n    rev = read_pipe([\"git\", \"rev-parse\", \"-q\", \"--verify\", ref],\n                     ignore_error=True)\n    return len(rev) > 0",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "isValidGitDir",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def isValidGitDir(path):\n    return git_dir(path) != None\ndef parseRevision(ref):\n    return read_pipe([\"git\", \"rev-parse\", ref]).strip()\ndef branchExists(ref):\n    rev = read_pipe([\"git\", \"rev-parse\", \"-q\", \"--verify\", ref],\n                     ignore_error=True)\n    return len(rev) > 0\ndef extractLogMessageFromGitCommit(commit):\n    logMessage = \"\"",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "parseRevision",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def parseRevision(ref):\n    return read_pipe([\"git\", \"rev-parse\", ref]).strip()\ndef branchExists(ref):\n    rev = read_pipe([\"git\", \"rev-parse\", \"-q\", \"--verify\", ref],\n                     ignore_error=True)\n    return len(rev) > 0\ndef extractLogMessageFromGitCommit(commit):\n    logMessage = \"\"\n    ## fixme: title is first line of commit, not 1st paragraph.\n    foundTitle = False",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "branchExists",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def branchExists(ref):\n    rev = read_pipe([\"git\", \"rev-parse\", \"-q\", \"--verify\", ref],\n                     ignore_error=True)\n    return len(rev) > 0\ndef extractLogMessageFromGitCommit(commit):\n    logMessage = \"\"\n    ## fixme: title is first line of commit, not 1st paragraph.\n    foundTitle = False\n    for log in read_pipe_lines([\"git\", \"cat-file\", \"commit\", commit]):\n       if not foundTitle:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "extractLogMessageFromGitCommit",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def extractLogMessageFromGitCommit(commit):\n    logMessage = \"\"\n    ## fixme: title is first line of commit, not 1st paragraph.\n    foundTitle = False\n    for log in read_pipe_lines([\"git\", \"cat-file\", \"commit\", commit]):\n       if not foundTitle:\n           if len(log) == 1:\n               foundTitle = True\n           continue\n       logMessage += log",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "extractSettingsGitLog",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def extractSettingsGitLog(log):\n    values = {}\n    for line in log.split(\"\\n\"):\n        line = line.strip()\n        m = re.search (r\"^ *\\[git-p4: (.*)\\]$\", line)\n        if not m:\n            continue\n        assignments = m.group(1).split (':')\n        for a in assignments:\n            vals = a.split ('=')",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "gitBranchExists",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def gitBranchExists(branch):\n    proc = subprocess.Popen([\"git\", \"rev-parse\", branch],\n                            stderr=subprocess.PIPE, stdout=subprocess.PIPE);\n    return proc.wait() == 0;\ndef gitUpdateRef(ref, newvalue):\n    subprocess.check_call([\"git\", \"update-ref\", ref, newvalue])\ndef gitDeleteRef(ref):\n    subprocess.check_call([\"git\", \"update-ref\", \"-d\", ref])\n_gitConfig = {}\ndef gitConfig(key, typeSpecifier=None):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "gitUpdateRef",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def gitUpdateRef(ref, newvalue):\n    subprocess.check_call([\"git\", \"update-ref\", ref, newvalue])\ndef gitDeleteRef(ref):\n    subprocess.check_call([\"git\", \"update-ref\", \"-d\", ref])\n_gitConfig = {}\ndef gitConfig(key, typeSpecifier=None):\n    if key not in _gitConfig:\n        cmd = [ \"git\", \"config\" ]\n        if typeSpecifier:\n            cmd += [ typeSpecifier ]",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "gitDeleteRef",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def gitDeleteRef(ref):\n    subprocess.check_call([\"git\", \"update-ref\", \"-d\", ref])\n_gitConfig = {}\ndef gitConfig(key, typeSpecifier=None):\n    if key not in _gitConfig:\n        cmd = [ \"git\", \"config\" ]\n        if typeSpecifier:\n            cmd += [ typeSpecifier ]\n        cmd += [ key ]\n        s = read_pipe(cmd, ignore_error=True)",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "gitConfig",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def gitConfig(key, typeSpecifier=None):\n    if key not in _gitConfig:\n        cmd = [ \"git\", \"config\" ]\n        if typeSpecifier:\n            cmd += [ typeSpecifier ]\n        cmd += [ key ]\n        s = read_pipe(cmd, ignore_error=True)\n        _gitConfig[key] = s.strip()\n    return _gitConfig[key]\ndef gitConfigBool(key):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "gitConfigBool",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def gitConfigBool(key):\n    \"\"\"Return a bool, using git config --bool.  It is True only if the\n       variable is set to true, and False if set to false or not present\n       in the config.\"\"\"\n    if key not in _gitConfig:\n        _gitConfig[key] = gitConfig(key, '--bool') == \"true\"\n    return _gitConfig[key]\ndef gitConfigInt(key):\n    if key not in _gitConfig:\n        cmd = [ \"git\", \"config\", \"--int\", key ]",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "gitConfigInt",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def gitConfigInt(key):\n    if key not in _gitConfig:\n        cmd = [ \"git\", \"config\", \"--int\", key ]\n        s = read_pipe(cmd, ignore_error=True)\n        v = s.strip()\n        try:\n            _gitConfig[key] = int(gitConfig(key, '--int'))\n        except ValueError:\n            _gitConfig[key] = None\n    return _gitConfig[key]",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "gitConfigList",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def gitConfigList(key):\n    if key not in _gitConfig:\n        s = read_pipe([\"git\", \"config\", \"--get-all\", key], ignore_error=True)\n        _gitConfig[key] = s.strip().splitlines()\n        if _gitConfig[key] == ['']:\n            _gitConfig[key] = []\n    return _gitConfig[key]\ndef p4BranchesInGit(branchesAreInRemotes=True):\n    \"\"\"Find all the branches whose names start with \"p4/\", looking\n       in remotes or heads as specified by the argument.  Return",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4BranchesInGit",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4BranchesInGit(branchesAreInRemotes=True):\n    \"\"\"Find all the branches whose names start with \"p4/\", looking\n       in remotes or heads as specified by the argument.  Return\n       a dictionary of { branch: revision } for each one found.\n       The branch names are the short names, without any\n       \"p4/\" prefix.\"\"\"\n    branches = {}\n    cmdline = [\"git\", \"rev-parse\", \"--symbolic\"]\n    if branchesAreInRemotes:\n        cmdline.append(\"--remotes\")",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "branch_exists",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def branch_exists(branch):\n    \"\"\"Make sure that the given ref name really exists.\"\"\"\n    cmd = [ \"git\", \"rev-parse\", \"--symbolic\", \"--verify\", branch ]\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    out, _ = p.communicate()\n    out = decode_text_stream(out)\n    if p.returncode:\n        return False\n    # expect exactly one line of output: the branch name\n    return out.rstrip() == branch",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "findUpstreamBranchPoint",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def findUpstreamBranchPoint(head = \"HEAD\"):\n    branches = p4BranchesInGit()\n    # map from depot-path to branch name\n    branchByDepotPath = {}\n    for branch in branches.keys():\n        tip = branches[branch]\n        log = extractLogMessageFromGitCommit(tip)\n        settings = extractSettingsGitLog(log)\n        if \"depot-paths\" in settings:\n            paths = \",\".join(settings[\"depot-paths\"])",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "createOrUpdateBranchesFromOrigin",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def createOrUpdateBranchesFromOrigin(localRefPrefix = \"refs/remotes/p4/\", silent=True):\n    if not silent:\n        print(\"Creating/updating branch(es) in %s based on origin branch(es)\"\n               % localRefPrefix)\n    originPrefix = \"origin/p4/\"\n    for line in read_pipe_lines([\"git\", \"rev-parse\", \"--symbolic\", \"--remotes\"]):\n        line = line.strip()\n        if (not line.startswith(originPrefix)) or line.endswith(\"HEAD\"):\n            continue\n        headName = line[len(originPrefix):]",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "originP4BranchesExist",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def originP4BranchesExist():\n        return gitBranchExists(\"origin\") or gitBranchExists(\"origin/p4\") or gitBranchExists(\"origin/p4/master\")\ndef p4ParseNumericChangeRange(parts):\n    changeStart = int(parts[0][1:])\n    if parts[1] == '#head':\n        changeEnd = p4_last_change()\n    else:\n        changeEnd = int(parts[1])\n    return (changeStart, changeEnd)\ndef chooseBlockSize(blockSize):",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4ParseNumericChangeRange",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4ParseNumericChangeRange(parts):\n    changeStart = int(parts[0][1:])\n    if parts[1] == '#head':\n        changeEnd = p4_last_change()\n    else:\n        changeEnd = int(parts[1])\n    return (changeStart, changeEnd)\ndef chooseBlockSize(blockSize):\n    if blockSize:\n        return blockSize",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "chooseBlockSize",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def chooseBlockSize(blockSize):\n    if blockSize:\n        return blockSize\n    else:\n        return defaultBlockSize\ndef p4ChangesForPaths(depotPaths, changeRange, requestedBlockSize):\n    assert depotPaths\n    # Parse the change range into start and end. Try to find integer\n    # revision ranges as these can be broken up into blocks to avoid\n    # hitting server-side limits (maxrows, maxscanresults). But if",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4ChangesForPaths",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4ChangesForPaths(depotPaths, changeRange, requestedBlockSize):\n    assert depotPaths\n    # Parse the change range into start and end. Try to find integer\n    # revision ranges as these can be broken up into blocks to avoid\n    # hitting server-side limits (maxrows, maxscanresults). But if\n    # that doesn't work, fall back to using the raw revision specifier\n    # strings, without using block mode.\n    if changeRange is None or changeRange == '':\n        changeStart = 1\n        changeEnd = p4_last_change()",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4PathStartsWith",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def p4PathStartsWith(path, prefix):\n    # This method tries to remedy a potential mixed-case issue:\n    #\n    # If UserA adds  //depot/DirA/file1\n    # and UserB adds //depot/dira/file2\n    #\n    # we may or may not have a problem. If you have core.ignorecase=true,\n    # we treat DirA and dira as the same directory\n    if gitConfigBool(\"core.ignorecase\"):\n        return path.lower().startswith(prefix.lower())",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "getClientSpec",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def getClientSpec():\n    \"\"\"Look at the p4 client spec, create a View() object that contains\n       all the mappings, and return it.\"\"\"\n    specList = p4CmdList([\"client\", \"-o\"])\n    if len(specList) != 1:\n        die('Output from \"client -o\" is %d lines, expecting 1' %\n            len(specList))\n    # dictionary of all client parameters\n    entry = specList[0]\n    # the //client/ name",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "getClientRoot",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def getClientRoot():\n    \"\"\"Grab the client directory.\"\"\"\n    output = p4CmdList([\"client\", \"-o\"])\n    if len(output) != 1:\n        die('Output from \"client -o\" is %d lines, expecting 1' % len(output))\n    entry = output[0]\n    if \"Root\" not in entry:\n        die('Client has no \"Root\"')\n    return entry[\"Root\"]\n#",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "wildcard_decode",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def wildcard_decode(path):\n    # Search for and fix just these four characters.  Do % last so\n    # that fixing it does not inadvertently create new %-escapes.\n    # Cannot have * in a filename in windows; untested as to\n    # what p4 would do in such a case.\n    if not platform.system() == \"Windows\":\n        path = path.replace(\"%2A\", \"*\")\n    path = path.replace(\"%23\", \"#\") \\\n               .replace(\"%40\", \"@\") \\\n               .replace(\"%25\", \"%\")",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "wildcard_encode",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def wildcard_encode(path):\n    # do % first to avoid double-encoding the %s introduced here\n    path = path.replace(\"%\", \"%25\") \\\n               .replace(\"*\", \"%2A\") \\\n               .replace(\"#\", \"%23\") \\\n               .replace(\"@\", \"%40\")\n    return path\ndef wildcard_present(path):\n    m = re.search(\"[*#@%]\", path)\n    return m is not None",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "wildcard_present",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def wildcard_present(path):\n    m = re.search(\"[*#@%]\", path)\n    return m is not None\nclass LargeFileSystem(object):\n    \"\"\"Base class for large file system support.\"\"\"\n    def __init__(self, writeToGitStream):\n        self.largeFiles = set()\n        self.writeToGitStream = writeToGitStream\n    def generatePointer(self, cloneDestination, contentFile):\n        \"\"\"Return the content of a pointer file that is stored in Git instead of",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "cloneExcludeCallback",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def cloneExcludeCallback(option, opt_str, value, parser):\n    # prepend \"/\" because the first \"/\" was consumed as part of the option itself.\n    # (\"-//depot/A/...\" becomes \"/depot/A/...\" after option parsing)\n    parser.values.cloneExclude += [\"/\" + re.sub(r\"\\.\\.\\.$\", \"\", value)]\nclass P4Sync(Command, P4UserMap):\n    def __init__(self):\n        Command.__init__(self)\n        P4UserMap.__init__(self)\n        self.options = [\n                optparse.make_option(\"--branch\", dest=\"branch\"),",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "printUsage",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def printUsage(commands):\n    print(\"usage: %s <command> [options]\" % sys.argv[0])\n    print(\"\")\n    print(\"valid commands: %s\" % \", \".join(commands))\n    print(\"\")\n    print(\"Try %s <command> --help for command specific help.\" % sys.argv[0])\n    print(\"\")\ncommands = {\n    \"submit\" : P4Submit,\n    \"commit\" : P4Submit,",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "def main():\n    if len(sys.argv[1:]) == 0:\n        printUsage(commands.keys())\n        sys.exit(2)\n    cmdName = sys.argv[1]\n    try:\n        klass = commands[cmdName]\n        cmd = klass()\n    except KeyError:\n        print(\"unknown command %s\" % cmdName)",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "verbose = False\n# Only labels/tags matching this will be imported/exported\ndefaultLabelRegexp = r'[a-zA-Z0-9_\\-.]+$'\n# The block size is reduced automatically if required\ndefaultBlockSize = 1<<20\np4_access_checked = False\nre_ko_keywords = re.compile(br'\\$(Id|Header)(:[^$\\n]+)?\\$')\nre_k_keywords = re.compile(br'\\$(Id|Header|Author|Date|DateTime|Change|File|Revision)(:[^$\\n]+)?\\$')\ndef format_size_human_readable(num):\n    \"\"\" Returns a number of units (typically bytes) formatted as a human-readable",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "defaultLabelRegexp",
        "kind": 5,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "defaultLabelRegexp = r'[a-zA-Z0-9_\\-.]+$'\n# The block size is reduced automatically if required\ndefaultBlockSize = 1<<20\np4_access_checked = False\nre_ko_keywords = re.compile(br'\\$(Id|Header)(:[^$\\n]+)?\\$')\nre_k_keywords = re.compile(br'\\$(Id|Header|Author|Date|DateTime|Change|File|Revision)(:[^$\\n]+)?\\$')\ndef format_size_human_readable(num):\n    \"\"\" Returns a number of units (typically bytes) formatted as a human-readable\n        string.\n    \"\"\"",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "defaultBlockSize",
        "kind": 5,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "defaultBlockSize = 1<<20\np4_access_checked = False\nre_ko_keywords = re.compile(br'\\$(Id|Header)(:[^$\\n]+)?\\$')\nre_k_keywords = re.compile(br'\\$(Id|Header|Author|Date|DateTime|Change|File|Revision)(:[^$\\n]+)?\\$')\ndef format_size_human_readable(num):\n    \"\"\" Returns a number of units (typically bytes) formatted as a human-readable\n        string.\n    \"\"\"\n    if num < 1024:\n        return '{:d} B'.format(num)",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "p4_access_checked",
        "kind": 5,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "p4_access_checked = False\nre_ko_keywords = re.compile(br'\\$(Id|Header)(:[^$\\n]+)?\\$')\nre_k_keywords = re.compile(br'\\$(Id|Header|Author|Date|DateTime|Change|File|Revision)(:[^$\\n]+)?\\$')\ndef format_size_human_readable(num):\n    \"\"\" Returns a number of units (typically bytes) formatted as a human-readable\n        string.\n    \"\"\"\n    if num < 1024:\n        return '{:d} B'.format(num)\n    for unit in [\"Ki\", \"Mi\", \"Gi\", \"Ti\", \"Pi\", \"Ei\", \"Zi\"]:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "re_ko_keywords",
        "kind": 5,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "re_ko_keywords = re.compile(br'\\$(Id|Header)(:[^$\\n]+)?\\$')\nre_k_keywords = re.compile(br'\\$(Id|Header|Author|Date|DateTime|Change|File|Revision)(:[^$\\n]+)?\\$')\ndef format_size_human_readable(num):\n    \"\"\" Returns a number of units (typically bytes) formatted as a human-readable\n        string.\n    \"\"\"\n    if num < 1024:\n        return '{:d} B'.format(num)\n    for unit in [\"Ki\", \"Mi\", \"Gi\", \"Ti\", \"Pi\", \"Ei\", \"Zi\"]:\n        num /= 1024.0",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "re_k_keywords",
        "kind": 5,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "re_k_keywords = re.compile(br'\\$(Id|Header|Author|Date|DateTime|Change|File|Revision)(:[^$\\n]+)?\\$')\ndef format_size_human_readable(num):\n    \"\"\" Returns a number of units (typically bytes) formatted as a human-readable\n        string.\n    \"\"\"\n    if num < 1024:\n        return '{:d} B'.format(num)\n    for unit in [\"Ki\", \"Mi\", \"Gi\", \"Ti\", \"Pi\", \"Ei\", \"Zi\"]:\n        num /= 1024.0\n        if num < 1024.0:",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "_p4_version_string",
        "kind": 5,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "_p4_version_string = None\ndef p4_version_string():\n    \"\"\"Read the version string, showing just the last line, which\n       hopefully is the interesting version bit.\n       $ p4 -V\n       Perforce - The Fast Software Configuration Management System.\n       Copyright 1995-2011 Perforce Software.  All rights reserved.\n       Rev. P4/NTX86/2011.1/393975 (2011/12/16).\n    \"\"\"\n    global _p4_version_string",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "_diff_tree_pattern",
        "kind": 5,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "_diff_tree_pattern = None\ndef parseDiffTreeEntry(entry):\n    \"\"\"Parses a single diff tree entry into its component elements.\n    See git-diff-tree(1) manpage for details about the format of the diff\n    output. This method returns a dictionary with the following elements:\n    src_mode - The mode of the source file\n    dst_mode - The mode of the destination file\n    src_sha1 - The sha1 for the source file\n    dst_sha1 - The sha1 fr the destination file\n    status - The one letter status of the diff (i.e. 'A', 'M', 'D', etc)",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "_gitConfig",
        "kind": 5,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "_gitConfig = {}\ndef gitConfig(key, typeSpecifier=None):\n    if key not in _gitConfig:\n        cmd = [ \"git\", \"config\" ]\n        if typeSpecifier:\n            cmd += [ typeSpecifier ]\n        cmd += [ key ]\n        s = read_pipe(cmd, ignore_error=True)\n        _gitConfig[key] = s.strip()\n    return _gitConfig[key]",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "commands",
        "kind": 5,
        "importPath": "git.git-p4",
        "description": "git.git-p4",
        "peekOfCode": "commands = {\n    \"submit\" : P4Submit,\n    \"commit\" : P4Submit,\n    \"sync\" : P4Sync,\n    \"rebase\" : P4Rebase,\n    \"clone\" : P4Clone,\n    \"branches\" : P4Branches,\n    \"unshelve\" : P4Unshelve,\n}\ndef main():",
        "detail": "git.git-p4",
        "documentation": {}
    },
    {
        "label": "maxCorrelationTime",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "maxCorrelationTime = 0\ncols = array.array(\"I\")\nnCols = 0\nargs = sys.argv[1:]\nindex = 0\nwhile index < len(args):\n  arg = args[index]\n  index += 1\n  if   (arg == \"-c\"):\n    cols.append(int(args[index])-1)",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "cols",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "cols = array.array(\"I\")\nnCols = 0\nargs = sys.argv[1:]\nindex = 0\nwhile index < len(args):\n  arg = args[index]\n  index += 1\n  if   (arg == \"-c\"):\n    cols.append(int(args[index])-1)\n    nCols += 1",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "nCols",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "nCols = 0\nargs = sys.argv[1:]\nindex = 0\nwhile index < len(args):\n  arg = args[index]\n  index += 1\n  if   (arg == \"-c\"):\n    cols.append(int(args[index])-1)\n    nCols += 1\n    index += 1",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "args = sys.argv[1:]\nindex = 0\nwhile index < len(args):\n  arg = args[index]\n  index += 1\n  if   (arg == \"-c\"):\n    cols.append(int(args[index])-1)\n    nCols += 1\n    index += 1\n  elif (arg == \"-s\"):",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "index = 0\nwhile index < len(args):\n  arg = args[index]\n  index += 1\n  if   (arg == \"-c\"):\n    cols.append(int(args[index])-1)\n    nCols += 1\n    index += 1\n  elif (arg == \"-s\"):\n    maxCorrelationTime = int(args[index])",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "data = [array.array(\"d\")]\nfor s in range(1,nCols)  : data.append( array.array(\"d\") )\n# read data block from log file\nstart = False\ninput = open(filename)\nnSamples = 0\npattern = re.compile('\\d')\nline = input.readline()\nwhile line :\n  columns = line.split()",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "start = False\ninput = open(filename)\nnSamples = 0\npattern = re.compile('\\d')\nline = input.readline()\nwhile line :\n  columns = line.split()\n  if (columns and pattern.match(columns[0])) :\n    for i in range(nCols): \n      data[i].append( float(columns[cols[i]]) )",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "input",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "input = open(filename)\nnSamples = 0\npattern = re.compile('\\d')\nline = input.readline()\nwhile line :\n  columns = line.split()\n  if (columns and pattern.match(columns[0])) :\n    for i in range(nCols): \n      data[i].append( float(columns[cols[i]]) )\n    nSamples += 1",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "nSamples",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "nSamples = 0\npattern = re.compile('\\d')\nline = input.readline()\nwhile line :\n  columns = line.split()\n  if (columns and pattern.match(columns[0])) :\n    for i in range(nCols): \n      data[i].append( float(columns[cols[i]]) )\n    nSamples += 1\n    start = True",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "pattern = re.compile('\\d')\nline = input.readline()\nwhile line :\n  columns = line.split()\n  if (columns and pattern.match(columns[0])) :\n    for i in range(nCols): \n      data[i].append( float(columns[cols[i]]) )\n    nSamples += 1\n    start = True\n  else :",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "line",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "line = input.readline()\nwhile line :\n  columns = line.split()\n  if (columns and pattern.match(columns[0])) :\n    for i in range(nCols): \n      data[i].append( float(columns[cols[i]]) )\n    nSamples += 1\n    start = True\n  else :\n     if (start) : break",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "correlationPairs",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "correlationPairs = []\nfor i in range(0,nCols):\n  for j in range(i,nCols): # note only upper triangle of the correlation matrix\n    correlationPairs.append([i,j])\nheader = \"# \"\nfor k in range(len(correlationPairs)):\n  i = str(correlationPairs[k][0]+1)\n  j = str(correlationPairs[k][1]+1)\n  header += \" C\"+i+j+\" sum_C\"+i+j\nprint header",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "header",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "header = \"# \"\nfor k in range(len(correlationPairs)):\n  i = str(correlationPairs[k][0]+1)\n  j = str(correlationPairs[k][1]+1)\n  header += \" C\"+i+j+\" sum_C\"+i+j\nprint header\nnCorrelationPairs = len(correlationPairs)\nsum = [0.0] * nCorrelationPairs\nfor s in range(maxCorrelationTime)  :\n  correlation = [0.0] * nCorrelationPairs",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "nCorrelationPairs",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "nCorrelationPairs = len(correlationPairs)\nsum = [0.0] * nCorrelationPairs\nfor s in range(maxCorrelationTime)  :\n  correlation = [0.0] * nCorrelationPairs\n  nt = nSamples-s\n  for t in range(0,nt)  :\n    for p in range(nCorrelationPairs):\n      i = correlationPairs[p][0]\n      j = correlationPairs[p][1]\n      correlation[p] += data[i][t]*data[j][s+t]",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "sum",
        "kind": 5,
        "importPath": "liggghts.doc.Scripts.correlate",
        "description": "liggghts.doc.Scripts.correlate",
        "peekOfCode": "sum = [0.0] * nCorrelationPairs\nfor s in range(maxCorrelationTime)  :\n  correlation = [0.0] * nCorrelationPairs\n  nt = nSamples-s\n  for t in range(0,nt)  :\n    for p in range(nCorrelationPairs):\n      i = correlationPairs[p][0]\n      j = correlationPairs[p][1]\n      correlation[p] += data[i][t]*data[j][s+t]\n  output = \"\"",
        "detail": "liggghts.doc.Scripts.correlate",
        "documentation": {}
    },
    {
        "label": "Lammps",
        "kind": 6,
        "importPath": "liggghts.tools.amber2lmp.amber2lammps",
        "description": "liggghts.tools.amber2lmp.amber2lammps",
        "peekOfCode": "class Lammps:\n    #--------------------------------------------------------\n    def Dump(self):\n        'Write out contents of self (intended for debugging)'\n        Name_list = self.__dict__.keys()\n        Name_list.sort()\n        for Name in Name_list:\n            print Name + ':', self.__dict__[Name]\n    #--------------------------------------------------------\n    def Write_data(self, Basename, Item_list):",
        "detail": "liggghts.tools.amber2lmp.amber2lammps",
        "documentation": {}
    },
    {
        "label": "Amber",
        "kind": 6,
        "importPath": "liggghts.tools.amber2lmp.amber2lammps",
        "description": "liggghts.tools.amber2lmp.amber2lammps",
        "peekOfCode": "class Amber:\n    def __init__(self):\n        'Initialise the Amber class'\n        self.CRD_is_read = 0\n        self.TOP_is_read = 0\n    #--------------------------------------------------------\n    def Dump(self):\n        'Write out contents of self (intended for debugging)'\n        Name_list = self.__dict__.keys()\n        Name_list.sort()",
        "detail": "liggghts.tools.amber2lmp.amber2lammps",
        "documentation": {}
    },
    {
        "label": "Pop",
        "kind": 2,
        "importPath": "liggghts.tools.amber2lmp.amber2lammps",
        "description": "liggghts.tools.amber2lmp.amber2lammps",
        "peekOfCode": "def Pop(S, I=-1):\n    'Pop item I from list'\n    X = S[I]\n    del S[I]\n    return X\n#============================================================\nclass Lammps:\n    #--------------------------------------------------------\n    def Dump(self):\n        'Write out contents of self (intended for debugging)'",
        "detail": "liggghts.tools.amber2lmp.amber2lammps",
        "documentation": {}
    },
    {
        "label": "Find_Amber_files",
        "kind": 2,
        "importPath": "liggghts.tools.amber2lmp.amber2lammps",
        "description": "liggghts.tools.amber2lmp.amber2lammps",
        "peekOfCode": "def Find_Amber_files():\n    'Look for sets of Amber files to process'\n    '''If not passed anything on the command line, look for pairs of\n    Amber files (.crd and .top) in the current directory.  For\n    each set if there is no corresponding Lammps file (data.), or it is\n    older than any of the Amber files, add its basename to a list of\n    strings.  This list is returned by the function'''\n    # Date and existence checks not yet implemented\n    import os, sys\n    Basename_list = []",
        "detail": "liggghts.tools.amber2lmp.amber2lammps",
        "documentation": {}
    },
    {
        "label": "Convert_Amber_files",
        "kind": 2,
        "importPath": "liggghts.tools.amber2lmp.amber2lammps",
        "description": "liggghts.tools.amber2lmp.amber2lammps",
        "peekOfCode": "def Convert_Amber_files():\n    'Handle the whole conversion process'\n    print\n    print 'Welcome to amber2lammps, a program to convert Amber files to Lammps format!'\n    print\n    Basename_list = Find_Amber_files()\n    for Basename in Basename_list:\n        a = Amber()\n        a.Read_CRD(Basename)\n        if a.CRD_is_read:",
        "detail": "liggghts.tools.amber2lmp.amber2lammps",
        "documentation": {}
    },
    {
        "label": "\tself.AMASS",
        "kind": 5,
        "importPath": "liggghts.tools.amber2lmp.amber2lammps",
        "description": "liggghts.tools.amber2lmp.amber2lammps",
        "peekOfCode": "\tself.AMASS = []\n        for i in range(self.NATOM):\n            self.AMASS.append(eval(Pop(Item_list,0)))\n\tprint 'Reading Atom Types...'\n        self.IAC = []\n        for i in range(self.NATOM):\n            self.IAC.append(eval(Pop(Item_list,0)))\n        print 'Reading Excluded Atoms...'\n\tself.NUMEX = []\n        for i in range(self.NATOM):",
        "detail": "liggghts.tools.amber2lmp.amber2lammps",
        "documentation": {}
    },
    {
        "label": "\tself.NUMEX",
        "kind": 5,
        "importPath": "liggghts.tools.amber2lmp.amber2lammps",
        "description": "liggghts.tools.amber2lmp.amber2lammps",
        "peekOfCode": "\tself.NUMEX = []\n        for i in range(self.NATOM):\n            self.NUMEX.append(eval(Pop(Item_list,0)))\n\tprint 'Reading Non-bonded Parameter Index...'\n        self.ICO = []\n        for i in range(self.NTYPES**2):\n            self.ICO.append(eval(Pop(Item_list,0)))\n        print 'Reading Residue Labels...'\n\tself.LABRES = []\n        for i in range(self.NRES):",
        "detail": "liggghts.tools.amber2lmp.amber2lammps",
        "documentation": {}
    },
    {
        "label": "\tself.LABRES",
        "kind": 5,
        "importPath": "liggghts.tools.amber2lmp.amber2lammps",
        "description": "liggghts.tools.amber2lmp.amber2lammps",
        "peekOfCode": "\tself.LABRES = []\n        for i in range(self.NRES):\n            self.LABRES.append(Pop(Item_list,0))\n        print 'Reading Residues Starting Pointers...'\n\tself.IPRES = []\n        for i in range(self.NRES):\n            self.IPRES.append(eval(Pop(Item_list,0)))\n\tprint 'Reading Bond Force Constants...'\n        self.RK = []\n        for i in range(self.NUMBND):",
        "detail": "liggghts.tools.amber2lmp.amber2lammps",
        "documentation": {}
    },
    {
        "label": "\tself.IPRES",
        "kind": 5,
        "importPath": "liggghts.tools.amber2lmp.amber2lammps",
        "description": "liggghts.tools.amber2lmp.amber2lammps",
        "peekOfCode": "\tself.IPRES = []\n        for i in range(self.NRES):\n            self.IPRES.append(eval(Pop(Item_list,0)))\n\tprint 'Reading Bond Force Constants...'\n        self.RK = []\n        for i in range(self.NUMBND):\n            self.RK.append(eval(Pop(Item_list,0)))\n\tprint 'Reading Equilibrium Bond Values...'\n        self.REQ = []\n        for i in range(self.NUMBND):",
        "detail": "liggghts.tools.amber2lmp.amber2lammps",
        "documentation": {}
    },
    {
        "label": "Snapshot",
        "kind": 6,
        "importPath": "liggghts.tools.amber2lmp.dump2trj",
        "description": "liggghts.tools.amber2lmp.dump2trj",
        "peekOfCode": "class Snapshot:\n    def __init__(self, The_trajectory):\n        'Initialise the Snapshot class'\n        self.timestep = The_trajectory.timestep\n        self.atoms = The_trajectory.atoms\n        self.xlo = The_trajectory.xlo\n        self.xhi = The_trajectory.xhi\n        self.ylo = The_trajectory.ylo\n        self.yhi = The_trajectory.yhi\n        self.zlo = The_trajectory.zlo",
        "detail": "liggghts.tools.amber2lmp.dump2trj",
        "documentation": {}
    },
    {
        "label": "Trajectory",
        "kind": 6,
        "importPath": "liggghts.tools.amber2lmp.dump2trj",
        "description": "liggghts.tools.amber2lmp.dump2trj",
        "peekOfCode": "class Trajectory:\n    def Read_dump(self, Basename):\n        'Read a Lammps position dump file'\n        import string, sys\n        Filename = Basename + '.dump'\n        print 'Reading', Filename + '...',\n        sys.stdout.flush()\n        try:\n            F = open(Filename)\n        except IOError, Detail:",
        "detail": "liggghts.tools.amber2lmp.dump2trj",
        "documentation": {}
    },
    {
        "label": "Convert_files",
        "kind": 2,
        "importPath": "liggghts.tools.amber2lmp.dump2trj",
        "description": "liggghts.tools.amber2lmp.dump2trj",
        "peekOfCode": "def Convert_files():\n    'Handle the whole conversion process'\n    print\n    print 'Welcome to dump2trj, a program to convert Lammps position dump files to\\nAmber trajectory format!'\n    print\n    Basename_list = Find_dump_files()\n    for Basename in Basename_list:\n        t = Trajectory()\n        if t.Read_dump(Basename):\n            t.Write_trj(Basename)",
        "detail": "liggghts.tools.amber2lmp.dump2trj",
        "documentation": {}
    },
    {
        "label": "Find_dump_files",
        "kind": 2,
        "importPath": "liggghts.tools.amber2lmp.dump2trj",
        "description": "liggghts.tools.amber2lmp.dump2trj",
        "peekOfCode": "def Find_dump_files():\n    'Look for sets of Lammps position dump files to process'\n    '''If passed something on the command line, treat it as a list of\n    files to process.  Otherwise, look for *.dump in the current\n    directory.\n    '''\n    import os, sys\n    Basename_list = []\n    # Extract basenames from command line\n    for Name in sys.argv[1:]:",
        "detail": "liggghts.tools.amber2lmp.dump2trj",
        "documentation": {}
    },
    {
        "label": "Float",
        "kind": 2,
        "importPath": "liggghts.tools.amber2lmp.dump2trj",
        "description": "liggghts.tools.amber2lmp.dump2trj",
        "peekOfCode": "def Float(s):\n    'Return the string s as a float, if possible'\n    try:\n        x = float(s)\n    except ValueError:\n        if s[-1] == ',':\n            s = s[:-1]\n        x = float(s)\n    return x\n#============================================================",
        "detail": "liggghts.tools.amber2lmp.dump2trj",
        "documentation": {}
    },
    {
        "label": "NumericalSort",
        "kind": 2,
        "importPath": "liggghts.tools.amber2lmp.dump2trj",
        "description": "liggghts.tools.amber2lmp.dump2trj",
        "peekOfCode": "def NumericalSort(String_list):\n    'Sort a list of strings by the integer value of the first element'\n    import string\n    Working_list = []\n    for s in String_list:\n        Working_list.append((int(string.split(s)[0]), s))\n    Working_list.sort()\n    Return_list = []\n    for Tuple in Working_list:\n        Return_list.append(Tuple[1])",
        "detail": "liggghts.tools.amber2lmp.dump2trj",
        "documentation": {}
    },
    {
        "label": "Snapshot",
        "kind": 6,
        "importPath": "liggghts.tools.amber2lmp.dump2trj99",
        "description": "liggghts.tools.amber2lmp.dump2trj99",
        "peekOfCode": "class Snapshot:\n    def __init__(self, The_trajectory):\n        'Initialise the Snapshot class'\n        self.atoms = The_trajectory.atoms\n        self.xlo = The_trajectory.xlo\n        self.xhi = The_trajectory.xhi\n        self.ylo = The_trajectory.ylo\n        self.yhi = The_trajectory.yhi\n        self.zlo = The_trajectory.zlo\n        self.zhi = The_trajectory.zhi",
        "detail": "liggghts.tools.amber2lmp.dump2trj99",
        "documentation": {}
    },
    {
        "label": "Trajectory",
        "kind": 6,
        "importPath": "liggghts.tools.amber2lmp.dump2trj99",
        "description": "liggghts.tools.amber2lmp.dump2trj99",
        "peekOfCode": "class Trajectory:\n    #--------------------------------------------------------\n    def Read_dump(self, Basename):\n        'Read a Lammps position dump file'\n        import string, sys\n        Filename = Basename + '.dump'\n        print 'Reading', Filename + '...',\n        sys.stdout.flush()\n        try:\n            F = open(Filename)",
        "detail": "liggghts.tools.amber2lmp.dump2trj99",
        "documentation": {}
    },
    {
        "label": "Convert_files",
        "kind": 2,
        "importPath": "liggghts.tools.amber2lmp.dump2trj99",
        "description": "liggghts.tools.amber2lmp.dump2trj99",
        "peekOfCode": "def Convert_files():\n    'Handle the whole conversion process'\n    print\n    print 'Welcome to dump2trj, a program to convert Lammps position dump files to\\nAmber trajectory format!'\n    print\n    Basename_list = Find_dump_files()\n    for Basename in Basename_list:\n        t = Trajectory()\n        if t.Read_dump(Basename):\n            t.Write_trj(Basename)",
        "detail": "liggghts.tools.amber2lmp.dump2trj99",
        "documentation": {}
    },
    {
        "label": "Find_dump_files",
        "kind": 2,
        "importPath": "liggghts.tools.amber2lmp.dump2trj99",
        "description": "liggghts.tools.amber2lmp.dump2trj99",
        "peekOfCode": "def Find_dump_files():\n    'Look for sets of Lammps position dump files to process'\n    '''If passed something on the command line, treat it as a list of\n    files to process.  Otherwise, look for *.dump in the current\n    directory.\n    '''\n    import os, sys\n    Basename_list = []\n    # Extract basenames from command line\n    for Name in sys.argv[1:]:",
        "detail": "liggghts.tools.amber2lmp.dump2trj99",
        "documentation": {}
    },
    {
        "label": "Float",
        "kind": 2,
        "importPath": "liggghts.tools.amber2lmp.dump2trj99",
        "description": "liggghts.tools.amber2lmp.dump2trj99",
        "peekOfCode": "def Float(s):\n    'Return the string s as a float, if possible'\n    try:\n        x = float(s)\n    except ValueError:\n        if s[-1] == ',':\n            s = s[:-1]\n        x = float(s)\n    return x\n#============================================================",
        "detail": "liggghts.tools.amber2lmp.dump2trj99",
        "documentation": {}
    },
    {
        "label": "cfg",
        "kind": 6,
        "importPath": "liggghts.tools.python.pizza.cfg",
        "description": "liggghts.tools.python.pizza.cfg",
        "peekOfCode": "class cfg:\n  # --------------------------------------------------------------------\n  def __init__(self,data):\n    self.data = data\n  # --------------------------------------------------------------------\n  def one(self,*args):\n    if len(args) == 0: file = \"tmp.cfg\"\n    elif args[0][-4:] == \".cfg\": file = args[0]\n    else: file = args[0] + \".cfg\"\n    f = open(file,\"w\")",
        "detail": "liggghts.tools.python.pizza.cfg",
        "documentation": {}
    },
    {
        "label": "oneline",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.cfg",
        "description": "liggghts.tools.python.pizza.cfg",
        "peekOfCode": "oneline = \"Convert LAMMPS snapshots to AtomEye CFG format\"\ndocstr = \"\"\"\nc = cfg(d)\t\td = object containing atom coords (dump, data)\nc.one()                 write all snapshots to tmp.cfg\nc.one(\"new\")            write all snapshots to new.cfg\nc.many()                write snapshots to tmp0000.cfg, tmp0001.cfg, etc\nc.many(\"new\")           write snapshots to new0000.cfg, new0001.cfg, etc\nc.single(N)             write snapshot for timestep N to tmp.cfg \nc.single(N,\"file\")      write snapshot for timestep N to file.cfg \n\"\"\"",
        "detail": "liggghts.tools.python.pizza.cfg",
        "documentation": {}
    },
    {
        "label": "docstr",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.cfg",
        "description": "liggghts.tools.python.pizza.cfg",
        "peekOfCode": "docstr = \"\"\"\nc = cfg(d)\t\td = object containing atom coords (dump, data)\nc.one()                 write all snapshots to tmp.cfg\nc.one(\"new\")            write all snapshots to new.cfg\nc.many()                write snapshots to tmp0000.cfg, tmp0001.cfg, etc\nc.many(\"new\")           write snapshots to new0000.cfg, new0001.cfg, etc\nc.single(N)             write snapshot for timestep N to tmp.cfg \nc.single(N,\"file\")      write snapshot for timestep N to file.cfg \n\"\"\"\n# History",
        "detail": "liggghts.tools.python.pizza.cfg",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.cfg",
        "description": "liggghts.tools.python.pizza.cfg",
        "peekOfCode": "c = cfg(d)\t\td = object containing atom coords (dump, data)\nc.one()                 write all snapshots to tmp.cfg\nc.one(\"new\")            write all snapshots to new.cfg\nc.many()                write snapshots to tmp0000.cfg, tmp0001.cfg, etc\nc.many(\"new\")           write snapshots to new0000.cfg, new0001.cfg, etc\nc.single(N)             write snapshot for timestep N to tmp.cfg \nc.single(N,\"file\")      write snapshot for timestep N to file.cfg \n\"\"\"\n# History\n#   11/06, Aidan Thompson (SNL): original version",
        "detail": "liggghts.tools.python.pizza.cfg",
        "documentation": {}
    },
    {
        "label": "dump",
        "kind": 6,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "class dump:\n  # --------------------------------------------------------------------\n  def __init__(self,*list):\n    self.snaps = []\n    self.nsnaps = self.nselect = 0\n    self.names = {}\n    self.tselect = tselect(self)\n    self.aselect = aselect(self)\n    self.atype = \"type\"\n    self.bondflag = 0",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "Snap",
        "kind": 6,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "class Snap:\n  pass\n# --------------------------------------------------------------------\n# time selection class\nclass tselect:\n  def __init__(self,data):\n    self.data = data\n  # --------------------------------------------------------------------\n  def all(self):\n    data = self.data",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "tselect",
        "kind": 6,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "class tselect:\n  def __init__(self,data):\n    self.data = data\n  # --------------------------------------------------------------------\n  def all(self):\n    data = self.data\n    for snap in data.snaps:\n      snap.tselect = 1\n    data.nselect = len(data.snaps)\n    data.aselect.all()",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "aselect",
        "kind": 6,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "class aselect:\n  def __init__(self,data):\n    self.data = data\n  # --------------------------------------------------------------------\n  def all(self,*args):\n    data = self.data\n    if len(args) == 0:                           # all selected timesteps\n      for snap in data.snaps:\n        if not snap.tselect: continue\n        for i in xrange(snap.natoms): snap.aselect[i] = 1",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "oneline",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "oneline = \"Read, write, manipulate dump files and particle attributes\"\ndocstr = \"\"\"\nd = dump(\"dump.one\")              read in one or more dump files\nd = dump(\"dump.1 dump.2.gz\")\t  can be gzipped\nd = dump(\"dump.*\")\t\t  wildcard expands to multiple files\nd = dump(\"dump.*\",0)\t\t  two args = store filenames, but don't read\n  incomplete and duplicate snapshots are deleted\n  if atoms have 5 or 8 columns, assign id,type,x,y,z (ix,iy,iz)\n  atoms will be unscaled if stored in files as scaled\ntime = d.next()             \t  read next snapshot from dump files",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "docstr",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "docstr = \"\"\"\nd = dump(\"dump.one\")              read in one or more dump files\nd = dump(\"dump.1 dump.2.gz\")\t  can be gzipped\nd = dump(\"dump.*\")\t\t  wildcard expands to multiple files\nd = dump(\"dump.*\",0)\t\t  two args = store filenames, but don't read\n  incomplete and duplicate snapshots are deleted\n  if atoms have 5 or 8 columns, assign id,type,x,y,z (ix,iy,iz)\n  atoms will be unscaled if stored in files as scaled\ntime = d.next()             \t  read next snapshot from dump files\n  used with 2-argument constructor to allow reading snapshots one-at-a-time",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "d = dump(\"dump.one\")              read in one or more dump files\nd = dump(\"dump.1 dump.2.gz\")\t  can be gzipped\nd = dump(\"dump.*\")\t\t  wildcard expands to multiple files\nd = dump(\"dump.*\",0)\t\t  two args = store filenames, but don't read\n  incomplete and duplicate snapshots are deleted\n  if atoms have 5 or 8 columns, assign id,type,x,y,z (ix,iy,iz)\n  atoms will be unscaled if stored in files as scaled\ntime = d.next()             \t  read next snapshot from dump files\n  used with 2-argument constructor to allow reading snapshots one-at-a-time\n  snapshot will be skipped only if another snapshot has same time stamp",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "d = dump(\"dump.1 dump.2.gz\")\t  can be gzipped\nd = dump(\"dump.*\")\t\t  wildcard expands to multiple files\nd = dump(\"dump.*\",0)\t\t  two args = store filenames, but don't read\n  incomplete and duplicate snapshots are deleted\n  if atoms have 5 or 8 columns, assign id,type,x,y,z (ix,iy,iz)\n  atoms will be unscaled if stored in files as scaled\ntime = d.next()             \t  read next snapshot from dump files\n  used with 2-argument constructor to allow reading snapshots one-at-a-time\n  snapshot will be skipped only if another snapshot has same time stamp\n  return time stamp of snapshot read",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "d = dump(\"dump.*\")\t\t  wildcard expands to multiple files\nd = dump(\"dump.*\",0)\t\t  two args = store filenames, but don't read\n  incomplete and duplicate snapshots are deleted\n  if atoms have 5 or 8 columns, assign id,type,x,y,z (ix,iy,iz)\n  atoms will be unscaled if stored in files as scaled\ntime = d.next()             \t  read next snapshot from dump files\n  used with 2-argument constructor to allow reading snapshots one-at-a-time\n  snapshot will be skipped only if another snapshot has same time stamp\n  return time stamp of snapshot read\n  return -1 if no snapshots left or last snapshot is incomplete",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "d = dump(\"dump.*\",0)\t\t  two args = store filenames, but don't read\n  incomplete and duplicate snapshots are deleted\n  if atoms have 5 or 8 columns, assign id,type,x,y,z (ix,iy,iz)\n  atoms will be unscaled if stored in files as scaled\ntime = d.next()             \t  read next snapshot from dump files\n  used with 2-argument constructor to allow reading snapshots one-at-a-time\n  snapshot will be skipped only if another snapshot has same time stamp\n  return time stamp of snapshot read\n  return -1 if no snapshots left or last snapshot is incomplete\n  no column name assignment or unscaling is performed",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "time = d.next()             \t  read next snapshot from dump files\n  used with 2-argument constructor to allow reading snapshots one-at-a-time\n  snapshot will be skipped only if another snapshot has same time stamp\n  return time stamp of snapshot read\n  return -1 if no snapshots left or last snapshot is incomplete\n  no column name assignment or unscaling is performed\nd.map(1,\"id\",3,\"x\")               assign names to atom columns (1-N)\n  not needed if dump file is self-describing\nd.tselect.all()\t\t\t  select all timesteps\nd.tselect.one(N)\t\t  select only timestep N",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "m1,m2",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "m1,m2 = d.minmax(\"type\")               find min/max values for a column\nd.set(\"$ke = $vx * $vx + $vy * $vy\")   set a column to a computed value\nd.spread(\"ke\",N,\"color\")\t       2nd col = N ints spread over 1st col\nd.clone(1000,\"color\")\t       \t       clone timestep N values to other steps\n  minmax() operates on selected timesteps and atoms\n  set() operates on selected timesteps and atoms\n    left hand side column is created if necessary\n    left-hand side column is unset or unchanged for non-selected atoms\n    equation is in Python syntax\n    use $ for column names, $name must end with a space",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "d.set(\"$ke",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "d.set(\"$ke = $vx * $vx + $vy * $vy\")   set a column to a computed value\nd.spread(\"ke\",N,\"color\")\t       2nd col = N ints spread over 1st col\nd.clone(1000,\"color\")\t       \t       clone timestep N values to other steps\n  minmax() operates on selected timesteps and atoms\n  set() operates on selected timesteps and atoms\n    left hand side column is created if necessary\n    left-hand side column is unset or unchanged for non-selected atoms\n    equation is in Python syntax\n    use $ for column names, $name must end with a space\n  spread() operates on selected timesteps and atoms",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "t = d.time()  \t     \t       \t   return vector of selected timestep values\nfx,fy,... = d.atom(100,\"fx\",\"fy\",...)   return vector(s) for atom ID N\nfx,fy,... = d.vecs(1000,\"fx\",\"fy\",...)  return vector(s) for timestep N\n  atom() returns vectors with one value for each selected timestep\n  vecs() returns vectors with one value for each selected atom in the timestep\nindex,time,flag = d.iterator(0/1)          loop over dump snapshots\ntime,box,atoms,bonds,tris = d.viz(index)   return list of viz objects\nd.atype = \"color\"                          set column returned as \"type\" by viz\nd.extra(\"dump.bond\")\t    \t\t   read bond list from dump file\nd.extra(data)\t\t\t\t   extract bond/tri/line list from data",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "fx,fy,...",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "fx,fy,... = d.atom(100,\"fx\",\"fy\",...)   return vector(s) for atom ID N\nfx,fy,... = d.vecs(1000,\"fx\",\"fy\",...)  return vector(s) for timestep N\n  atom() returns vectors with one value for each selected timestep\n  vecs() returns vectors with one value for each selected atom in the timestep\nindex,time,flag = d.iterator(0/1)          loop over dump snapshots\ntime,box,atoms,bonds,tris = d.viz(index)   return list of viz objects\nd.atype = \"color\"                          set column returned as \"type\" by viz\nd.extra(\"dump.bond\")\t    \t\t   read bond list from dump file\nd.extra(data)\t\t\t\t   extract bond/tri/line list from data\n  iterator() loops over selected timesteps",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "fx,fy,...",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "fx,fy,... = d.vecs(1000,\"fx\",\"fy\",...)  return vector(s) for timestep N\n  atom() returns vectors with one value for each selected timestep\n  vecs() returns vectors with one value for each selected atom in the timestep\nindex,time,flag = d.iterator(0/1)          loop over dump snapshots\ntime,box,atoms,bonds,tris = d.viz(index)   return list of viz objects\nd.atype = \"color\"                          set column returned as \"type\" by viz\nd.extra(\"dump.bond\")\t    \t\t   read bond list from dump file\nd.extra(data)\t\t\t\t   extract bond/tri/line list from data\n  iterator() loops over selected timesteps\n  iterator() called with arg = 0 first time, with arg = 1 on subsequent calls",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "index,time,flag",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "index,time,flag = d.iterator(0/1)          loop over dump snapshots\ntime,box,atoms,bonds,tris = d.viz(index)   return list of viz objects\nd.atype = \"color\"                          set column returned as \"type\" by viz\nd.extra(\"dump.bond\")\t    \t\t   read bond list from dump file\nd.extra(data)\t\t\t\t   extract bond/tri/line list from data\n  iterator() loops over selected timesteps\n  iterator() called with arg = 0 first time, with arg = 1 on subsequent calls\n    index = index within dump object (0 to # of snapshots)\n    time = timestep value\n    flag = -1 when iteration is done, 1 otherwise",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "time,box,atoms,bonds,tris",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "time,box,atoms,bonds,tris = d.viz(index)   return list of viz objects\nd.atype = \"color\"                          set column returned as \"type\" by viz\nd.extra(\"dump.bond\")\t    \t\t   read bond list from dump file\nd.extra(data)\t\t\t\t   extract bond/tri/line list from data\n  iterator() loops over selected timesteps\n  iterator() called with arg = 0 first time, with arg = 1 on subsequent calls\n    index = index within dump object (0 to # of snapshots)\n    time = timestep value\n    flag = -1 when iteration is done, 1 otherwise\n  viz() returns info for selected atoms for specified timestep index",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "d.atype",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "d.atype = \"color\"                          set column returned as \"type\" by viz\nd.extra(\"dump.bond\")\t    \t\t   read bond list from dump file\nd.extra(data)\t\t\t\t   extract bond/tri/line list from data\n  iterator() loops over selected timesteps\n  iterator() called with arg = 0 first time, with arg = 1 on subsequent calls\n    index = index within dump object (0 to # of snapshots)\n    time = timestep value\n    flag = -1 when iteration is done, 1 otherwise\n  viz() returns info for selected atoms for specified timestep index\n    time = timestep value",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "\tself.eof",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.dump",
        "description": "liggghts.tools.python.pizza.dump",
        "peekOfCode": "\tself.eof = 0\n\tcontinue\n      self.eof = f.tell()\n      f.close()\n      try:\n        self.findtime(snap.time)\n\tcontinue\n      except: break\n    # select the new snapshot with all its atoms\n    self.snaps.append(snap)",
        "detail": "liggghts.tools.python.pizza.dump",
        "documentation": {}
    },
    {
        "label": "gnu",
        "kind": 6,
        "importPath": "liggghts.tools.python.pizza.gnu",
        "description": "liggghts.tools.python.pizza.gnu",
        "peekOfCode": "class gnu:\n  # --------------------------------------------------------------------\n  def __init__(self):\n    self.GNUPLOT = os.popen(PIZZA_GNUPLOT,'w')\n    self.file = \"tmp.gnu\"\n    self.figures = []\n    self.select(1)\n  # --------------------------------------------------------------------\n  def stop(self):\n    self.__call__(\"quit\")",
        "detail": "liggghts.tools.python.pizza.gnu",
        "documentation": {}
    },
    {
        "label": "figure",
        "kind": 6,
        "importPath": "liggghts.tools.python.pizza.gnu",
        "description": "liggghts.tools.python.pizza.gnu",
        "peekOfCode": "class figure:\n  def __init__(self):\n    self.ncurves = 0\n    self.colors  = []    \n    self.title   = \"\"\n    self.xtitle  = \"\"\n    self.ytitle  = \"\"\n    self.aspect  = 1.3\n    self.xlimit  = 0\n    self.ylimit  = 0",
        "detail": "liggghts.tools.python.pizza.gnu",
        "documentation": {}
    },
    {
        "label": "oneline",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.gnu",
        "description": "liggghts.tools.python.pizza.gnu",
        "peekOfCode": "oneline = \"Create plots via GnuPlot plotting program\"\ndocstr = \"\"\"\ng = gnu()\t\t       start up GnuPlot\ng.stop()\t\t       shut down GnuPlot process\ng.plot(a)                      plot vector A against linear index\ng.plot(a,b)\t \t       plot B against A\ng.plot(a,b,c,d,...)\t       plot B against A, D against C, etc\ng.mplot(M,N,S,\"file\",a,b,...)  multiple plots saved to file0000.eps, etc\n  each plot argument can be a tuple, list, or Numeric vector\n  mplot loops over range(M,N,S) and create one plot per iteration",
        "detail": "liggghts.tools.python.pizza.gnu",
        "documentation": {}
    },
    {
        "label": "docstr",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.gnu",
        "description": "liggghts.tools.python.pizza.gnu",
        "peekOfCode": "docstr = \"\"\"\ng = gnu()\t\t       start up GnuPlot\ng.stop()\t\t       shut down GnuPlot process\ng.plot(a)                      plot vector A against linear index\ng.plot(a,b)\t \t       plot B against A\ng.plot(a,b,c,d,...)\t       plot B against A, D against C, etc\ng.mplot(M,N,S,\"file\",a,b,...)  multiple plots saved to file0000.eps, etc\n  each plot argument can be a tuple, list, or Numeric vector\n  mplot loops over range(M,N,S) and create one plot per iteration\n    last args are same as list of vectors for plot(), e.g. 1, 2, 4 vectors",
        "detail": "liggghts.tools.python.pizza.gnu",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.gnu",
        "description": "liggghts.tools.python.pizza.gnu",
        "peekOfCode": "g = gnu()\t\t       start up GnuPlot\ng.stop()\t\t       shut down GnuPlot process\ng.plot(a)                      plot vector A against linear index\ng.plot(a,b)\t \t       plot B against A\ng.plot(a,b,c,d,...)\t       plot B against A, D against C, etc\ng.mplot(M,N,S,\"file\",a,b,...)  multiple plots saved to file0000.eps, etc\n  each plot argument can be a tuple, list, or Numeric vector\n  mplot loops over range(M,N,S) and create one plot per iteration\n    last args are same as list of vectors for plot(), e.g. 1, 2, 4 vectors\n    each plot is made from a portion of the vectors, depending on loop index i",
        "detail": "liggghts.tools.python.pizza.gnu",
        "documentation": {}
    },
    {
        "label": "colormap",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.gnu",
        "description": "liggghts.tools.python.pizza.gnu",
        "peekOfCode": "colormap = {'k':-1, 'r':1, 'g':2, 'b':3, 'm':4, 'c':5, 'y':7}",
        "detail": "liggghts.tools.python.pizza.gnu",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 6,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "class log:\n  # --------------------------------------------------------------------\n  def __init__(self,*list):\n    self.nvec = 0\n    self.names = []\n    self.ptr = {}\n    self.data = []\n    # flist = list of all log file names\n    words = list[0].split()\n    self.flist = []",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "oneline",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "oneline = \"Read LAMMPS log files and extract thermodynamic data\"\ndocstr = \"\"\"\nl = log(\"file1\")                     read in one or more log files\nl = log(\"log1 log2.gz\")              can be gzipped\nl = log(\"file*\")                     wildcard expands to multiple files\nl = log(\"log.lammps\",0)              two args = store filename, but don't read\n  incomplete and duplicate thermo entries are deleted\ntime = l.next()                      read new thermo info from file\n  used with 2-argument constructor to allow reading thermo incrementally\n  return time stamp of last thermo read",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "docstr",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "docstr = \"\"\"\nl = log(\"file1\")                     read in one or more log files\nl = log(\"log1 log2.gz\")              can be gzipped\nl = log(\"file*\")                     wildcard expands to multiple files\nl = log(\"log.lammps\",0)              two args = store filename, but don't read\n  incomplete and duplicate thermo entries are deleted\ntime = l.next()                      read new thermo info from file\n  used with 2-argument constructor to allow reading thermo incrementally\n  return time stamp of last thermo read\n  return -1 if no new thermo since last read",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "l = log(\"file1\")                     read in one or more log files\nl = log(\"log1 log2.gz\")              can be gzipped\nl = log(\"file*\")                     wildcard expands to multiple files\nl = log(\"log.lammps\",0)              two args = store filename, but don't read\n  incomplete and duplicate thermo entries are deleted\ntime = l.next()                      read new thermo info from file\n  used with 2-argument constructor to allow reading thermo incrementally\n  return time stamp of last thermo read\n  return -1 if no new thermo since last read\nnvec = l.nvec                        # of vectors of thermo info",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "l = log(\"log1 log2.gz\")              can be gzipped\nl = log(\"file*\")                     wildcard expands to multiple files\nl = log(\"log.lammps\",0)              two args = store filename, but don't read\n  incomplete and duplicate thermo entries are deleted\ntime = l.next()                      read new thermo info from file\n  used with 2-argument constructor to allow reading thermo incrementally\n  return time stamp of last thermo read\n  return -1 if no new thermo since last read\nnvec = l.nvec                        # of vectors of thermo info\nnlen = l.nlen                        length of each vectors",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "l = log(\"file*\")                     wildcard expands to multiple files\nl = log(\"log.lammps\",0)              two args = store filename, but don't read\n  incomplete and duplicate thermo entries are deleted\ntime = l.next()                      read new thermo info from file\n  used with 2-argument constructor to allow reading thermo incrementally\n  return time stamp of last thermo read\n  return -1 if no new thermo since last read\nnvec = l.nvec                        # of vectors of thermo info\nnlen = l.nlen                        length of each vectors\nnames = l.names                      list of vector names",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "l = log(\"log.lammps\",0)              two args = store filename, but don't read\n  incomplete and duplicate thermo entries are deleted\ntime = l.next()                      read new thermo info from file\n  used with 2-argument constructor to allow reading thermo incrementally\n  return time stamp of last thermo read\n  return -1 if no new thermo since last read\nnvec = l.nvec                        # of vectors of thermo info\nnlen = l.nlen                        length of each vectors\nnames = l.names                      list of vector names\nt,pe,... = l.get(\"Time\",\"KE\",...)    return one or more vectors of values",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "time = l.next()                      read new thermo info from file\n  used with 2-argument constructor to allow reading thermo incrementally\n  return time stamp of last thermo read\n  return -1 if no new thermo since last read\nnvec = l.nvec                        # of vectors of thermo info\nnlen = l.nlen                        length of each vectors\nnames = l.names                      list of vector names\nt,pe,... = l.get(\"Time\",\"KE\",...)    return one or more vectors of values\nl.write(\"file.txt\")\t \t     write all vectors to a file\nl.write(\"file.txt\",\"Time\",\"PE\",...)  write listed vectors to a file",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "nvec",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "nvec = l.nvec                        # of vectors of thermo info\nnlen = l.nlen                        length of each vectors\nnames = l.names                      list of vector names\nt,pe,... = l.get(\"Time\",\"KE\",...)    return one or more vectors of values\nl.write(\"file.txt\")\t \t     write all vectors to a file\nl.write(\"file.txt\",\"Time\",\"PE\",...)  write listed vectors to a file\n  get and write allow abbreviated (uniquely) vector names\n\"\"\"\n# History\n#   8/05, Steve Plimpton (SNL): original version",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "nlen",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "nlen = l.nlen                        length of each vectors\nnames = l.names                      list of vector names\nt,pe,... = l.get(\"Time\",\"KE\",...)    return one or more vectors of values\nl.write(\"file.txt\")\t \t     write all vectors to a file\nl.write(\"file.txt\",\"Time\",\"PE\",...)  write listed vectors to a file\n  get and write allow abbreviated (uniquely) vector names\n\"\"\"\n# History\n#   8/05, Steve Plimpton (SNL): original version\n# ToDo list",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "names",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "names = l.names                      list of vector names\nt,pe,... = l.get(\"Time\",\"KE\",...)    return one or more vectors of values\nl.write(\"file.txt\")\t \t     write all vectors to a file\nl.write(\"file.txt\",\"Time\",\"PE\",...)  write listed vectors to a file\n  get and write allow abbreviated (uniquely) vector names\n\"\"\"\n# History\n#   8/05, Steve Plimpton (SNL): original version\n# ToDo list\n# Variables",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "t,pe,...",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "t,pe,... = l.get(\"Time\",\"KE\",...)    return one or more vectors of values\nl.write(\"file.txt\")\t \t     write all vectors to a file\nl.write(\"file.txt\",\"Time\",\"PE\",...)  write listed vectors to a file\n  get and write allow abbreviated (uniquely) vector names\n\"\"\"\n# History\n#   8/05, Steve Plimpton (SNL): original version\n# ToDo list\n# Variables\n#   nvec = # of vectors",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "\tlast",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "\tlast = 1\n        s1 = 0\n      elif s1 >= 0 and s2 == -1:             # found s1, but no s2\n        last = 1\n        if self.style == 1:\n          s2 = txt.rfind(\"\\n--\",s1) + 1\n        else:\n\t  s1 = txt.find(\"\\n\",s1) + 1\n          s2 = txt.rfind(\"\\n\",s1) + 1\n\teof -= len(txt) - s2",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "\tlast",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.log",
        "description": "liggghts.tools.python.pizza.log",
        "peekOfCode": "\tlast = 1                                      # entire read is a chunk\n        s1 = 0\n        if self.style == 1:\n          s2 = txt.rfind(\"\\n--\",s1) + 1\n        else:\n          s2 = txt.rfind(\"\\n\",s1) + 1\n\teof -= len(txt) - s2\n\tif s1 == s2: break\n      chunk = txt[s1:s2-1]\n      start = s2",
        "detail": "liggghts.tools.python.pizza.log",
        "documentation": {}
    },
    {
        "label": "pdbfile",
        "kind": 6,
        "importPath": "liggghts.tools.python.pizza.pdbfile",
        "description": "liggghts.tools.python.pizza.pdbfile",
        "peekOfCode": "class pdbfile:\n  # --------------------------------------------------------------------\n  def __init__(self,*args):\n    if len(args) == 1:\n      if type(args[0]) is types.StringType:\n        filestr = args[0]\n        self.data = None\n      else:\n        filestr = None\n        self.data = args[0]",
        "detail": "liggghts.tools.python.pizza.pdbfile",
        "documentation": {}
    },
    {
        "label": "oneline",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.pdbfile",
        "description": "liggghts.tools.python.pizza.pdbfile",
        "peekOfCode": "oneline = \"Read, write PDB files in combo with LAMMPS snapshots\"\ndocstr = \"\"\"\np = pdbfile(\"3CRO\")         create pdb object from PDB file or WWW\np = pdbfile(\"pep1 pep2\")    read in multiple PDB files\np = pdbfile(\"pep*\")         can use wildcards\np = pdbfile(d)              read in snapshot data with no PDB file\np = pdbfile(\"3CRO\",d)       read in single PDB file with snapshot data\n  string arg contains one or more PDB files\n    don't need .pdb suffix except wildcard must expand to file.pdb\n    if only one 4-char file specified and it is not found,",
        "detail": "liggghts.tools.python.pizza.pdbfile",
        "documentation": {}
    },
    {
        "label": "docstr",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.pdbfile",
        "description": "liggghts.tools.python.pizza.pdbfile",
        "peekOfCode": "docstr = \"\"\"\np = pdbfile(\"3CRO\")         create pdb object from PDB file or WWW\np = pdbfile(\"pep1 pep2\")    read in multiple PDB files\np = pdbfile(\"pep*\")         can use wildcards\np = pdbfile(d)              read in snapshot data with no PDB file\np = pdbfile(\"3CRO\",d)       read in single PDB file with snapshot data\n  string arg contains one or more PDB files\n    don't need .pdb suffix except wildcard must expand to file.pdb\n    if only one 4-char file specified and it is not found,\n      it will be downloaded from http://www.rcsb.org as 3CRO.pdb",
        "detail": "liggghts.tools.python.pizza.pdbfile",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.pdbfile",
        "description": "liggghts.tools.python.pizza.pdbfile",
        "peekOfCode": "p = pdbfile(\"3CRO\")         create pdb object from PDB file or WWW\np = pdbfile(\"pep1 pep2\")    read in multiple PDB files\np = pdbfile(\"pep*\")         can use wildcards\np = pdbfile(d)              read in snapshot data with no PDB file\np = pdbfile(\"3CRO\",d)       read in single PDB file with snapshot data\n  string arg contains one or more PDB files\n    don't need .pdb suffix except wildcard must expand to file.pdb\n    if only one 4-char file specified and it is not found,\n      it will be downloaded from http://www.rcsb.org as 3CRO.pdb\n  d arg is object with atom coordinates (dump, data)",
        "detail": "liggghts.tools.python.pizza.pdbfile",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.pdbfile",
        "description": "liggghts.tools.python.pizza.pdbfile",
        "peekOfCode": "p = pdbfile(\"pep1 pep2\")    read in multiple PDB files\np = pdbfile(\"pep*\")         can use wildcards\np = pdbfile(d)              read in snapshot data with no PDB file\np = pdbfile(\"3CRO\",d)       read in single PDB file with snapshot data\n  string arg contains one or more PDB files\n    don't need .pdb suffix except wildcard must expand to file.pdb\n    if only one 4-char file specified and it is not found,\n      it will be downloaded from http://www.rcsb.org as 3CRO.pdb\n  d arg is object with atom coordinates (dump, data)\np.one()                     write all output as one big PDB file to tmp.pdb",
        "detail": "liggghts.tools.python.pizza.pdbfile",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.pdbfile",
        "description": "liggghts.tools.python.pizza.pdbfile",
        "peekOfCode": "p = pdbfile(\"pep*\")         can use wildcards\np = pdbfile(d)              read in snapshot data with no PDB file\np = pdbfile(\"3CRO\",d)       read in single PDB file with snapshot data\n  string arg contains one or more PDB files\n    don't need .pdb suffix except wildcard must expand to file.pdb\n    if only one 4-char file specified and it is not found,\n      it will be downloaded from http://www.rcsb.org as 3CRO.pdb\n  d arg is object with atom coordinates (dump, data)\np.one()                     write all output as one big PDB file to tmp.pdb\np.one(\"mine\")               write to mine.pdb",
        "detail": "liggghts.tools.python.pizza.pdbfile",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.pdbfile",
        "description": "liggghts.tools.python.pizza.pdbfile",
        "peekOfCode": "p = pdbfile(d)              read in snapshot data with no PDB file\np = pdbfile(\"3CRO\",d)       read in single PDB file with snapshot data\n  string arg contains one or more PDB files\n    don't need .pdb suffix except wildcard must expand to file.pdb\n    if only one 4-char file specified and it is not found,\n      it will be downloaded from http://www.rcsb.org as 3CRO.pdb\n  d arg is object with atom coordinates (dump, data)\np.one()                     write all output as one big PDB file to tmp.pdb\np.one(\"mine\")               write to mine.pdb\np.many()                    write one PDB file per snapshot: tmp0000.pdb, ...",
        "detail": "liggghts.tools.python.pizza.pdbfile",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.pdbfile",
        "description": "liggghts.tools.python.pizza.pdbfile",
        "peekOfCode": "p = pdbfile(\"3CRO\",d)       read in single PDB file with snapshot data\n  string arg contains one or more PDB files\n    don't need .pdb suffix except wildcard must expand to file.pdb\n    if only one 4-char file specified and it is not found,\n      it will be downloaded from http://www.rcsb.org as 3CRO.pdb\n  d arg is object with atom coordinates (dump, data)\np.one()                     write all output as one big PDB file to tmp.pdb\np.one(\"mine\")               write to mine.pdb\np.many()                    write one PDB file per snapshot: tmp0000.pdb, ...\np.many(\"mine\")              write as mine0000.pdb, mine0001.pdb, ...",
        "detail": "liggghts.tools.python.pizza.pdbfile",
        "documentation": {}
    },
    {
        "label": "index,time,flag",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.pdbfile",
        "description": "liggghts.tools.python.pizza.pdbfile",
        "peekOfCode": "index,time,flag = p.iterator(0)\nindex,time,flag = p.iterator(1)\n  iterator = loop over number of PDB files\n    call first time with arg = 0, thereafter with arg = 1\n    N = length = # of snapshots or # of input PDB files\n    index = index of snapshot or input PDB file (0 to N-1)\n    time = timestep value (time stamp for snapshot, index for multiple PDB)\n    flag = -1 when iteration is done, 1 otherwise\n  typically call p.single(time) in iterated loop to write out one PDB file\n\"\"\"",
        "detail": "liggghts.tools.python.pizza.pdbfile",
        "documentation": {}
    },
    {
        "label": "index,time,flag",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.pdbfile",
        "description": "liggghts.tools.python.pizza.pdbfile",
        "peekOfCode": "index,time,flag = p.iterator(1)\n  iterator = loop over number of PDB files\n    call first time with arg = 0, thereafter with arg = 1\n    N = length = # of snapshots or # of input PDB files\n    index = index of snapshot or input PDB file (0 to N-1)\n    time = timestep value (time stamp for snapshot, index for multiple PDB)\n    flag = -1 when iteration is done, 1 otherwise\n  typically call p.single(time) in iterated loop to write out one PDB file\n\"\"\"\n# History",
        "detail": "liggghts.tools.python.pizza.pdbfile",
        "documentation": {}
    },
    {
        "label": "xyz",
        "kind": 6,
        "importPath": "liggghts.tools.python.pizza.xyz",
        "description": "liggghts.tools.python.pizza.xyz",
        "peekOfCode": "class xyz:\n  # --------------------------------------------------------------------\n  def __init__(self,data):\n    self.data = data\n  # --------------------------------------------------------------------\n  def one(self,*args):\n    if len(args) == 0: file = \"tmp.xyz\"\n    elif args[0][-4:] == \".xyz\": file = args[0]\n    else: file = args[0] + \".xyz\"\n    f = open(file,\"w\")",
        "detail": "liggghts.tools.python.pizza.xyz",
        "documentation": {}
    },
    {
        "label": "oneline",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.xyz",
        "description": "liggghts.tools.python.pizza.xyz",
        "peekOfCode": "oneline = \"Convert LAMMPS snapshots to XYZ format\"\ndocstr = \"\"\"\nx = xyz(d)\t\td = object containing atom coords (dump, data)\nx.one()                 write all snapshots to tmp.xyz\nx.one(\"new\")            write all snapshots to new.xyz\nx.many()                write snapshots to tmp0000.xyz, tmp0001.xyz, etc\nx.many(\"new\")           write snapshots to new0000.xyz, new0001.xyz, etc\nx.single(N)             write snapshot for timestep N to tmp.xyz \nx.single(N,\"file\")      write snapshot for timestep N to file.xyz \n\"\"\"",
        "detail": "liggghts.tools.python.pizza.xyz",
        "documentation": {}
    },
    {
        "label": "docstr",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.xyz",
        "description": "liggghts.tools.python.pizza.xyz",
        "peekOfCode": "docstr = \"\"\"\nx = xyz(d)\t\td = object containing atom coords (dump, data)\nx.one()                 write all snapshots to tmp.xyz\nx.one(\"new\")            write all snapshots to new.xyz\nx.many()                write snapshots to tmp0000.xyz, tmp0001.xyz, etc\nx.many(\"new\")           write snapshots to new0000.xyz, new0001.xyz, etc\nx.single(N)             write snapshot for timestep N to tmp.xyz \nx.single(N,\"file\")      write snapshot for timestep N to file.xyz \n\"\"\"\n# History",
        "detail": "liggghts.tools.python.pizza.xyz",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "liggghts.tools.python.pizza.xyz",
        "description": "liggghts.tools.python.pizza.xyz",
        "peekOfCode": "x = xyz(d)\t\td = object containing atom coords (dump, data)\nx.one()                 write all snapshots to tmp.xyz\nx.one(\"new\")            write all snapshots to new.xyz\nx.many()                write snapshots to tmp0000.xyz, tmp0001.xyz, etc\nx.many(\"new\")           write snapshots to new0000.xyz, new0001.xyz, etc\nx.single(N)             write snapshot for timestep N to tmp.xyz \nx.single(N,\"file\")      write snapshot for timestep N to file.xyz \n\"\"\"\n# History\n#   8/05, Steve Plimpton (SNL): original version",
        "detail": "liggghts.tools.python.pizza.xyz",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2cfg",
        "description": "liggghts.tools.python.dump2cfg",
        "peekOfCode": "path = os.environ[\"LAMMPS_PYTHON_TOOLS\"]\nsys.path.append(path)\nfrom dump import dump\nfrom cfg import cfg\nif len(sys.argv) != 8:\n  raise StandardError, \"Syntax: dump2cfg.py dumpfile Nid Ntype Nx Ny Nz cfgfile\"\ndumpfile = sys.argv[1]\nnid = int(sys.argv[2])\nntype = int(sys.argv[3])\nnx = int(sys.argv[4])",
        "detail": "liggghts.tools.python.dump2cfg",
        "documentation": {}
    },
    {
        "label": "dumpfile",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2cfg",
        "description": "liggghts.tools.python.dump2cfg",
        "peekOfCode": "dumpfile = sys.argv[1]\nnid = int(sys.argv[2])\nntype = int(sys.argv[3])\nnx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\ncfgfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nc = cfg(d)",
        "detail": "liggghts.tools.python.dump2cfg",
        "documentation": {}
    },
    {
        "label": "nid",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2cfg",
        "description": "liggghts.tools.python.dump2cfg",
        "peekOfCode": "nid = int(sys.argv[2])\nntype = int(sys.argv[3])\nnx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\ncfgfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nc = cfg(d)\nc.one(cfgfile)",
        "detail": "liggghts.tools.python.dump2cfg",
        "documentation": {}
    },
    {
        "label": "ntype",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2cfg",
        "description": "liggghts.tools.python.dump2cfg",
        "peekOfCode": "ntype = int(sys.argv[3])\nnx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\ncfgfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nc = cfg(d)\nc.one(cfgfile)",
        "detail": "liggghts.tools.python.dump2cfg",
        "documentation": {}
    },
    {
        "label": "nx",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2cfg",
        "description": "liggghts.tools.python.dump2cfg",
        "peekOfCode": "nx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\ncfgfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nc = cfg(d)\nc.one(cfgfile)",
        "detail": "liggghts.tools.python.dump2cfg",
        "documentation": {}
    },
    {
        "label": "ny",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2cfg",
        "description": "liggghts.tools.python.dump2cfg",
        "peekOfCode": "ny = int(sys.argv[5])\nnz = int(sys.argv[6])\ncfgfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nc = cfg(d)\nc.one(cfgfile)",
        "detail": "liggghts.tools.python.dump2cfg",
        "documentation": {}
    },
    {
        "label": "nz",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2cfg",
        "description": "liggghts.tools.python.dump2cfg",
        "peekOfCode": "nz = int(sys.argv[6])\ncfgfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nc = cfg(d)\nc.one(cfgfile)",
        "detail": "liggghts.tools.python.dump2cfg",
        "documentation": {}
    },
    {
        "label": "cfgfile",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2cfg",
        "description": "liggghts.tools.python.dump2cfg",
        "peekOfCode": "cfgfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nc = cfg(d)\nc.one(cfgfile)",
        "detail": "liggghts.tools.python.dump2cfg",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2cfg",
        "description": "liggghts.tools.python.dump2cfg",
        "peekOfCode": "d = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nc = cfg(d)\nc.one(cfgfile)",
        "detail": "liggghts.tools.python.dump2cfg",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2cfg",
        "description": "liggghts.tools.python.dump2cfg",
        "peekOfCode": "c = cfg(d)\nc.one(cfgfile)",
        "detail": "liggghts.tools.python.dump2cfg",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2pdb",
        "description": "liggghts.tools.python.dump2pdb",
        "peekOfCode": "path = os.environ[\"LAMMPS_PYTHON_TOOLS\"]\nsys.path.append(path)\nfrom dump import dump\nfrom pdbfile import pdbfile\nif len(sys.argv) != 8 and len(sys.argv) != 9:\n  raise StandardError, \"Syntax: dump2pdb.py dumpfile Nid Ntype Nx Ny Nz pdbfile template\"\ndumpfile = sys.argv[1]\nnid = int(sys.argv[2])\nntype = int(sys.argv[3])\nnx = int(sys.argv[4])",
        "detail": "liggghts.tools.python.dump2pdb",
        "documentation": {}
    },
    {
        "label": "dumpfile",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2pdb",
        "description": "liggghts.tools.python.dump2pdb",
        "peekOfCode": "dumpfile = sys.argv[1]\nnid = int(sys.argv[2])\nntype = int(sys.argv[3])\nnx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\npfile = sys.argv[7]\nif len(sys.argv) == 9: template = sys.argv[8]\nelse: template = \"\"\nd = dump(dumpfile)",
        "detail": "liggghts.tools.python.dump2pdb",
        "documentation": {}
    },
    {
        "label": "nid",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2pdb",
        "description": "liggghts.tools.python.dump2pdb",
        "peekOfCode": "nid = int(sys.argv[2])\nntype = int(sys.argv[3])\nnx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\npfile = sys.argv[7]\nif len(sys.argv) == 9: template = sys.argv[8]\nelse: template = \"\"\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")",
        "detail": "liggghts.tools.python.dump2pdb",
        "documentation": {}
    },
    {
        "label": "ntype",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2pdb",
        "description": "liggghts.tools.python.dump2pdb",
        "peekOfCode": "ntype = int(sys.argv[3])\nnx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\npfile = sys.argv[7]\nif len(sys.argv) == 9: template = sys.argv[8]\nelse: template = \"\"\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nif template: p = pdbfile(template,d)",
        "detail": "liggghts.tools.python.dump2pdb",
        "documentation": {}
    },
    {
        "label": "nx",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2pdb",
        "description": "liggghts.tools.python.dump2pdb",
        "peekOfCode": "nx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\npfile = sys.argv[7]\nif len(sys.argv) == 9: template = sys.argv[8]\nelse: template = \"\"\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nif template: p = pdbfile(template,d)\nelse: p = pdbfile(d)",
        "detail": "liggghts.tools.python.dump2pdb",
        "documentation": {}
    },
    {
        "label": "ny",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2pdb",
        "description": "liggghts.tools.python.dump2pdb",
        "peekOfCode": "ny = int(sys.argv[5])\nnz = int(sys.argv[6])\npfile = sys.argv[7]\nif len(sys.argv) == 9: template = sys.argv[8]\nelse: template = \"\"\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nif template: p = pdbfile(template,d)\nelse: p = pdbfile(d)\np.one(pfile)",
        "detail": "liggghts.tools.python.dump2pdb",
        "documentation": {}
    },
    {
        "label": "nz",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2pdb",
        "description": "liggghts.tools.python.dump2pdb",
        "peekOfCode": "nz = int(sys.argv[6])\npfile = sys.argv[7]\nif len(sys.argv) == 9: template = sys.argv[8]\nelse: template = \"\"\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nif template: p = pdbfile(template,d)\nelse: p = pdbfile(d)\np.one(pfile)",
        "detail": "liggghts.tools.python.dump2pdb",
        "documentation": {}
    },
    {
        "label": "pfile",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2pdb",
        "description": "liggghts.tools.python.dump2pdb",
        "peekOfCode": "pfile = sys.argv[7]\nif len(sys.argv) == 9: template = sys.argv[8]\nelse: template = \"\"\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nif template: p = pdbfile(template,d)\nelse: p = pdbfile(d)\np.one(pfile)",
        "detail": "liggghts.tools.python.dump2pdb",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2pdb",
        "description": "liggghts.tools.python.dump2pdb",
        "peekOfCode": "d = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nif template: p = pdbfile(template,d)\nelse: p = pdbfile(d)\np.one(pfile)",
        "detail": "liggghts.tools.python.dump2pdb",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2xyz",
        "description": "liggghts.tools.python.dump2xyz",
        "peekOfCode": "path = os.environ[\"LAMMPS_PYTHON_TOOLS\"]\nsys.path.append(path)\nfrom dump import dump\nfrom xyz import xyz\nif len(sys.argv) != 8:\n  raise StandardError, \"Syntax: dump2xyz.py dumpfile Nid Ntype Nx Ny Nz xyzfile\"\ndumpfile = sys.argv[1]\nnid = int(sys.argv[2])\nntype = int(sys.argv[3])\nnx = int(sys.argv[4])",
        "detail": "liggghts.tools.python.dump2xyz",
        "documentation": {}
    },
    {
        "label": "dumpfile",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2xyz",
        "description": "liggghts.tools.python.dump2xyz",
        "peekOfCode": "dumpfile = sys.argv[1]\nnid = int(sys.argv[2])\nntype = int(sys.argv[3])\nnx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\nxyzfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nx = xyz(d)",
        "detail": "liggghts.tools.python.dump2xyz",
        "documentation": {}
    },
    {
        "label": "nid",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2xyz",
        "description": "liggghts.tools.python.dump2xyz",
        "peekOfCode": "nid = int(sys.argv[2])\nntype = int(sys.argv[3])\nnx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\nxyzfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nx = xyz(d)\nx.one(xyzfile)",
        "detail": "liggghts.tools.python.dump2xyz",
        "documentation": {}
    },
    {
        "label": "ntype",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2xyz",
        "description": "liggghts.tools.python.dump2xyz",
        "peekOfCode": "ntype = int(sys.argv[3])\nnx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\nxyzfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nx = xyz(d)\nx.one(xyzfile)",
        "detail": "liggghts.tools.python.dump2xyz",
        "documentation": {}
    },
    {
        "label": "nx",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2xyz",
        "description": "liggghts.tools.python.dump2xyz",
        "peekOfCode": "nx = int(sys.argv[4])\nny = int(sys.argv[5])\nnz = int(sys.argv[6])\nxyzfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nx = xyz(d)\nx.one(xyzfile)",
        "detail": "liggghts.tools.python.dump2xyz",
        "documentation": {}
    },
    {
        "label": "ny",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2xyz",
        "description": "liggghts.tools.python.dump2xyz",
        "peekOfCode": "ny = int(sys.argv[5])\nnz = int(sys.argv[6])\nxyzfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nx = xyz(d)\nx.one(xyzfile)",
        "detail": "liggghts.tools.python.dump2xyz",
        "documentation": {}
    },
    {
        "label": "nz",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2xyz",
        "description": "liggghts.tools.python.dump2xyz",
        "peekOfCode": "nz = int(sys.argv[6])\nxyzfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nx = xyz(d)\nx.one(xyzfile)",
        "detail": "liggghts.tools.python.dump2xyz",
        "documentation": {}
    },
    {
        "label": "xyzfile",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2xyz",
        "description": "liggghts.tools.python.dump2xyz",
        "peekOfCode": "xyzfile = sys.argv[7]\nd = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nx = xyz(d)\nx.one(xyzfile)",
        "detail": "liggghts.tools.python.dump2xyz",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2xyz",
        "description": "liggghts.tools.python.dump2xyz",
        "peekOfCode": "d = dump(dumpfile)\nd.map(nid,\"id\",ntype,\"type\",nx,\"x\",ny,\"y\",nz,\"z\")\nx = xyz(d)\nx.one(xyzfile)",
        "detail": "liggghts.tools.python.dump2xyz",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "liggghts.tools.python.dump2xyz",
        "description": "liggghts.tools.python.dump2xyz",
        "peekOfCode": "x = xyz(d)\nx.one(xyzfile)",
        "detail": "liggghts.tools.python.dump2xyz",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "liggghts.tools.python.dumpsort",
        "description": "liggghts.tools.python.dumpsort",
        "peekOfCode": "path = os.environ[\"LAMMPS_PYTHON_TOOLS\"]\nsys.path.append(path)\nfrom dump import dump\nif len(sys.argv) != 4:\n  raise StandardError, \"Syntax: dumpsort.py oldfile N newfile\"\noldfile = sys.argv[1]\nncolumn = int(sys.argv[2])\nnewfile = sys.argv[3]\nd = dump(oldfile)\nd.map(ncolumn,\"id\")",
        "detail": "liggghts.tools.python.dumpsort",
        "documentation": {}
    },
    {
        "label": "oldfile",
        "kind": 5,
        "importPath": "liggghts.tools.python.dumpsort",
        "description": "liggghts.tools.python.dumpsort",
        "peekOfCode": "oldfile = sys.argv[1]\nncolumn = int(sys.argv[2])\nnewfile = sys.argv[3]\nd = dump(oldfile)\nd.map(ncolumn,\"id\")\nd.sort()\nd.write(newfile)",
        "detail": "liggghts.tools.python.dumpsort",
        "documentation": {}
    },
    {
        "label": "ncolumn",
        "kind": 5,
        "importPath": "liggghts.tools.python.dumpsort",
        "description": "liggghts.tools.python.dumpsort",
        "peekOfCode": "ncolumn = int(sys.argv[2])\nnewfile = sys.argv[3]\nd = dump(oldfile)\nd.map(ncolumn,\"id\")\nd.sort()\nd.write(newfile)",
        "detail": "liggghts.tools.python.dumpsort",
        "documentation": {}
    },
    {
        "label": "newfile",
        "kind": 5,
        "importPath": "liggghts.tools.python.dumpsort",
        "description": "liggghts.tools.python.dumpsort",
        "peekOfCode": "newfile = sys.argv[3]\nd = dump(oldfile)\nd.map(ncolumn,\"id\")\nd.sort()\nd.write(newfile)",
        "detail": "liggghts.tools.python.dumpsort",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "liggghts.tools.python.dumpsort",
        "description": "liggghts.tools.python.dumpsort",
        "peekOfCode": "d = dump(oldfile)\nd.map(ncolumn,\"id\")\nd.sort()\nd.write(newfile)",
        "detail": "liggghts.tools.python.dumpsort",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "liggghts.tools.python.log2txt",
        "description": "liggghts.tools.python.log2txt",
        "peekOfCode": "path = os.environ[\"LAMMPS_PYTHON_TOOLS\"]\nsys.path.append(path)\nfrom log import log\nif len(sys.argv) < 3:\n  raise StandardError, \"Syntax: log2txt.py log.lammps data.txt X Y ...\"\nlogfile = sys.argv[1]\ndatafile = sys.argv[2]\ncolumns = sys.argv[3:]\nlg = log(logfile)\nif columns == []:",
        "detail": "liggghts.tools.python.log2txt",
        "documentation": {}
    },
    {
        "label": "logfile",
        "kind": 5,
        "importPath": "liggghts.tools.python.log2txt",
        "description": "liggghts.tools.python.log2txt",
        "peekOfCode": "logfile = sys.argv[1]\ndatafile = sys.argv[2]\ncolumns = sys.argv[3:]\nlg = log(logfile)\nif columns == []:\n  lg.write(datafile)\nelse:\n  str = \"lg.write(datafile,\"\n  for word in columns: str += '\"' + word + '\",'\n  str = str[:-1] + ')'",
        "detail": "liggghts.tools.python.log2txt",
        "documentation": {}
    },
    {
        "label": "datafile",
        "kind": 5,
        "importPath": "liggghts.tools.python.log2txt",
        "description": "liggghts.tools.python.log2txt",
        "peekOfCode": "datafile = sys.argv[2]\ncolumns = sys.argv[3:]\nlg = log(logfile)\nif columns == []:\n  lg.write(datafile)\nelse:\n  str = \"lg.write(datafile,\"\n  for word in columns: str += '\"' + word + '\",'\n  str = str[:-1] + ')'\n  eval(str)",
        "detail": "liggghts.tools.python.log2txt",
        "documentation": {}
    },
    {
        "label": "columns",
        "kind": 5,
        "importPath": "liggghts.tools.python.log2txt",
        "description": "liggghts.tools.python.log2txt",
        "peekOfCode": "columns = sys.argv[3:]\nlg = log(logfile)\nif columns == []:\n  lg.write(datafile)\nelse:\n  str = \"lg.write(datafile,\"\n  for word in columns: str += '\"' + word + '\",'\n  str = str[:-1] + ')'\n  eval(str)",
        "detail": "liggghts.tools.python.log2txt",
        "documentation": {}
    },
    {
        "label": "lg",
        "kind": 5,
        "importPath": "liggghts.tools.python.log2txt",
        "description": "liggghts.tools.python.log2txt",
        "peekOfCode": "lg = log(logfile)\nif columns == []:\n  lg.write(datafile)\nelse:\n  str = \"lg.write(datafile,\"\n  for word in columns: str += '\"' + word + '\",'\n  str = str[:-1] + ')'\n  eval(str)",
        "detail": "liggghts.tools.python.log2txt",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "liggghts.tools.python.logplot",
        "description": "liggghts.tools.python.logplot",
        "peekOfCode": "path = os.environ[\"LAMMPS_PYTHON_TOOLS\"]\nsys.path.append(path)\nfrom log import log\nfrom gnu import gnu\nif len(sys.argv) != 4:\n  raise StandardError, \"Syntax: logplot.py log.lammps X Y\"\nlogfile = sys.argv[1]\nxlabel = sys.argv[2]\nylabel = sys.argv[3]\nlg = log(logfile)",
        "detail": "liggghts.tools.python.logplot",
        "documentation": {}
    },
    {
        "label": "logfile",
        "kind": 5,
        "importPath": "liggghts.tools.python.logplot",
        "description": "liggghts.tools.python.logplot",
        "peekOfCode": "logfile = sys.argv[1]\nxlabel = sys.argv[2]\nylabel = sys.argv[3]\nlg = log(logfile)\nx,y = lg.get(xlabel,ylabel)\ng = gnu()\ng.plot(x,y)\nprint \"Type Ctrl-D to exit Python\"",
        "detail": "liggghts.tools.python.logplot",
        "documentation": {}
    },
    {
        "label": "xlabel",
        "kind": 5,
        "importPath": "liggghts.tools.python.logplot",
        "description": "liggghts.tools.python.logplot",
        "peekOfCode": "xlabel = sys.argv[2]\nylabel = sys.argv[3]\nlg = log(logfile)\nx,y = lg.get(xlabel,ylabel)\ng = gnu()\ng.plot(x,y)\nprint \"Type Ctrl-D to exit Python\"",
        "detail": "liggghts.tools.python.logplot",
        "documentation": {}
    },
    {
        "label": "ylabel",
        "kind": 5,
        "importPath": "liggghts.tools.python.logplot",
        "description": "liggghts.tools.python.logplot",
        "peekOfCode": "ylabel = sys.argv[3]\nlg = log(logfile)\nx,y = lg.get(xlabel,ylabel)\ng = gnu()\ng.plot(x,y)\nprint \"Type Ctrl-D to exit Python\"",
        "detail": "liggghts.tools.python.logplot",
        "documentation": {}
    },
    {
        "label": "lg",
        "kind": 5,
        "importPath": "liggghts.tools.python.logplot",
        "description": "liggghts.tools.python.logplot",
        "peekOfCode": "lg = log(logfile)\nx,y = lg.get(xlabel,ylabel)\ng = gnu()\ng.plot(x,y)\nprint \"Type Ctrl-D to exit Python\"",
        "detail": "liggghts.tools.python.logplot",
        "documentation": {}
    },
    {
        "label": "x,y",
        "kind": 5,
        "importPath": "liggghts.tools.python.logplot",
        "description": "liggghts.tools.python.logplot",
        "peekOfCode": "x,y = lg.get(xlabel,ylabel)\ng = gnu()\ng.plot(x,y)\nprint \"Type Ctrl-D to exit Python\"",
        "detail": "liggghts.tools.python.logplot",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 5,
        "importPath": "liggghts.tools.python.logplot",
        "description": "liggghts.tools.python.logplot",
        "peekOfCode": "g = gnu()\ng.plot(x,y)\nprint \"Type Ctrl-D to exit Python\"",
        "detail": "liggghts.tools.python.logplot",
        "documentation": {}
    },
    {
        "label": "MyappConfig",
        "kind": 6,
        "importPath": "myapp.apps",
        "description": "myapp.apps",
        "peekOfCode": "class MyappConfig(AppConfig):\n    default_auto_field = 'django.db.models.BigAutoField'\n    name = 'myapp'",
        "detail": "myapp.apps",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "manage",
        "description": "manage",
        "peekOfCode": "def main():\n    \"\"\"Run administrative tasks.\"\"\"\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'deployment.settings.local')\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"",
        "detail": "manage",
        "documentation": {}
    }
]